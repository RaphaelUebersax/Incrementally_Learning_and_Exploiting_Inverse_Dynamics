classdef IncBudgetGPRegressor
    
   % Definition of all attribute for this class
   properties
      Sigma_n_         % Noise added to the GPR model 
      Sigma_f_         % Covariance noise of the RBF kernel
      Sigma_rbf_       % Lengthscale coefficient of the RBF kernel
      Budget_          % Maximum number of datapoints in Kernel
      K_noise_         % Gram Matrix with noise (K+sigma_n^2*I)
      K_inv_           % Inverse of K_noise
      X_train_         % Datapoint in training set considered
      y_train_         % Target of training data
      F_mean_train_    % Mean of training data
      Alpha_           % Weight coefficient
            
   end
   
   
   methods
       
      % Constructor of the class to assign input values to properties
      function obj = IncBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f)
         if nargin == 4
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = Sigma_f;
            
         elseif nargin == 3
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = 1;
         else
             msg = "Wrong number of input parameters for this class!";
             msg = msg + newline + newline + "RequiredInputs are:";
             msg = msg + newline + "   1) Budget    (int): Max number of datapoints";
             msg = msg + newline + "   2) Sigma_rbf (double): RBF kernel lengthscale";
             msg = msg + newline + "   3) Sigma_n   (double): Noise added to incremental GPR";
             error(msg)
         end
                  
      end
      
      
      % Main function to check if add new point to model or not
      function obj = update(obj, x, y, f_mean)
              
          if size(obj.X_train_,1) < obj.Budget_
              obj = obj.increment(x, y, f_mean);
          else
              index = obj.check_similarity(x);
              if index ~= (obj.Budget_+1)
                  obj = obj.decrement(idx);
                  obj = obj.increment(x,y,f_mean);
              end
          end
          
      end
      
      
      % Find index of datapoint with the least information
      function idx = check_similarity(obj,x)
             Gram_mean = mean(obj.K_noise_,1);
             New_mean = mean(obj.RBF_kernel_star(x));
             [~,idx] = min([Gram_mean, New_mean]);
      end
      
      
      % Compute the kernel k(X_train,x_test) datapoint wise
      function K_star = RBF_kernel_star(obj, X_test)
          nms = -1*pdist2(X_test,obj.X_train_,'squaredeuclidean');
          K_star = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*nms);
      end
      
      % Computes the rbf kernel of x with xd
      function k_noise = RBF_kernel(obj,x)
          k = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*(x*x'));
          k_noise = k + [obj.Sigma_n_]^2;
      end
      
      
      % Incrementing the GPR model
      function obj = increment(obj, x, y, f_mean)
         if isempty(obj.X_train_)
            obj.K_noise_ = [obj.Sigma_f_]^2;
            obj.K_inv_ = 1/[obj.Sigma_f_]^2;
            obj.X_train_ = x;
            obj.y_train_ = y;
            obj.F_mean_train_ = f_mean;
            
         else 
             % update the (K+sigma_n^2I) matrix
             b = obj.RBF_kernel_star(x)';
             c = obj.RBF_kernel(x);
             obj.K_noise_ = [obj.K_noise_, b; b', c];
             
             % update the (K+sigma_n^2I)^(-1) matrix
             d = c-b'*obj.K_inv_*b;
             a1 = obj.K_inv_ + 1/d*obj.K_inv_*b*b'*obj.K_inv_;
             a2 = -1/d*obj.K_inv_*b;
             a3 = -1/d*b'*obj.K_inv_;
             a4 = 1/d;
             obj.K_inv_ = [a1,a2;a3,a4];
             
             % update the training set
             obj.X_train_ = [obj.X_train_;x];
             obj.y_train_ = [obj.y_train_;y];
             obj.F_mean_train_ = [obj.F_mean_train_;f_mean];
             
         end
                 
      end
      
      
      % Decrement the matrix to be able to add the new point
      function obj = decrement(obj,index)
          if index ~= obj.Budget_
              memory_row = obj.K_noise_(end,:);
              memory_column = obj.K_noise_(:,end);
              obj.K_noise_(end,:) = obj.K_noise_(index,:);
              obj.K_noise_(:,end) = obj.K_noise_(:,index);
              obj.K_noise_(index,:) = memory_row;
              obj.K_noise_(:,index) = memory_column;
          end
          
          % Block matrices required
          b = obj.K_noise_(end,1:end-1)';
          c = obj.K_noise_(end,end);
          d = obj.K_inv_(1:end-1,1:end-1);
          
          %update K_noise
          obj.K_noise_ = obj.K_noise_(1:end-1,1:end-1
          
          
      end
      
      
      
      % Used the training data to compute alpha
      function obj = fit(obj)
         obj.Alpha_ = obj.K_inv_*(obj.y_train_-obj.F_mean_train_);
      end
      
      % Predict the target value for a new input with the GPR
      function y = predict(obj, X_test, F_mean)
          K_star = obj.RBF_kernel_star(X_test);
          y = F_mean + K_star*obj.Alpha_;
      end
      
      
   end
end