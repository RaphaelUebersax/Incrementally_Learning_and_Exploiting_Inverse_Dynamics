%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO COMPUTE THE GAUSSIAN PROCESS REGRESSION WITH PRIOR
% KNOWLEDE ABOUT THE IDEAL RBD FOR JOINT NUMBER 2 USING AN INCREMENTAL
% TECHNIQUE
%
% Last edition: 18.10.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;
close all;
clc;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% VARIABLES TO SET BEFORE RUNNING THE SCRIPT !!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Choose if loading small data set or take new data from complete set
small_dataset = false;   % Set to true if using preexisting file
N = 1000;                % number of data rows to load if from complete set
M = 500;                 % number of data rows to add to test without train
n_steps = 20;            % Set intervall between two successive datapoints

% Choose parameters for the GPR learning method
train_test_ratio = 0.3;

% Choose if comparing GPR with prior to without
comparison = true;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];

% Name of complete and small data file
small_filename = '../data/gprProcessedActualData.csv';
filename = '../../Complete_data/processedActualData.csv';


%% Load the data from complete data file (only run the 1st time)

% Load the N first rows of the data from csv file (exluding time)
% pos 1-7 | dpos 1-7 | ddpos 1-7 | torque 1-7

if (small_dataset == false)
    data = csvread(filename,1,1,[1,1,N*n_steps,28]); % Variable containing the data
    data = data([1:n_steps:end],:);

    % Load data afterwards seperatly to only include in the test 
    data_away = csvread(filename,N*n_steps+1,1,[N*n_steps+1,1,N*n_steps+M*n_steps,28]); % Variable containing the data
    data_away = data_away([1:n_steps:end],:); 

    % write smaller dataset into a csv file
    data_to_write = [data',data_away']';   % complete dataset
    delimitation = size(data,1);           % information on seperation between data and data_away
    delimitation_vector = delimitation*ones(size(data_to_write,1),1);
    data_to_write = [data_to_write,delimitation_vector];
    
    if exist(small_filename, 'file')==2
      delete(small_filename);             % delete old file if exists
    end
    writematrix(data_to_write,small_filename);
    
else
    if isfile(small_filename)
         data_complete = readmatrix(small_filename);
         data = data_complete(1:data_complete(1,29),1:28);
         data_away = data_complete(data_complete(1,29):end, 1:28);
    else
         error('Small dataset not found');
    end
end




%% Split the data into train and test set

% Assign variables to train and test sets
index_plot = [1:size(data,1)];  % keep track of data position for plots
data = [data, index_plot'];
cv = cvpartition(size(data,1),'HoldOut',train_test_ratio);
idx = cv.test;


% Separate to training and test data
dataTrain = data(~idx,:);
dataTest  = data(idx,:);

train_X =  dataTrain(:,1:14);
train_y = dataTrain(:,23);
test_X = [dataTest(:,1:14);data_away(:,1:14)];
test_y = [dataTest(:,23);data_away(:,23)];

% Keep track of index for plots
x_plot_train = dataTrain(:,29);
x_plot_test_1 = dataTest(:,29);
x_plot_test_2 = [(size(data,1)+1):(size(data,1)+size(data_away,1))]';
x_plot_test = [x_plot_test_1', x_plot_test_2']';

% Training joint parameters for RBD
train_joint_pos = train_X(:,1:7);                % Joint Position   
train_joint_vel = train_X(:,8:14);               % Joint Velocity
train_joint_acc = zeros(size(train_X,1),7);      % Joint Acceleration
   
% Testing joint parameters for RBD
test_joint_pos = test_X(:,1:7);                  % Joint Position   
test_joint_vel = test_X(:,8:14);                 % Joint Velocity
test_joint_acc = zeros(size(test_X,1),7);        % Joint Acceleration



%% Computation of ideal RBD from robot model 

% initialize vector of correct size
train_RBD = zeros(size(train_X,1),7);
test_RBD = zeros(size(test_X,1),7);

% ideal inverse dynamics of the robot for using it as the mean for train
for i=1:size(train_X,1)
    train_RBD(i,:) = inverseDynamics(robot,train_joint_pos(i,:), ...
        train_joint_pos(i,:), train_joint_acc(i,:));
end

% ideal inverse dynamics of the robot for using it as the mean for test
for i=1:size(test_X,1)
    test_RBD(i,:) = inverseDynamics(robot,test_joint_pos(i,:), ...
        test_joint_pos(i,:),test_joint_acc(i,:));
end

% Inverse the torque value from measured to exercing
train_RBD = -1*train_RBD;
test_RBD = -1*test_RBD;

% Load values for joint 2 only
train_RBD_joint2 = train_RBD(:,2);
test_RBD_joint2 = test_RBD(:,2);


%% Gaussian Process Regression with prior knowledge 
Sigma_n = 9.16;
Sigma_rbf = 2.19;
Sigma_f = 12.5675;


if comparison == true
    myGPR = GPRegressor(Sigma_rbf,Sigma_n, Sigma_f);
    myGPR = myGPR.fit(train_X, train_y, train_RBD_joint2);
    ypred_train_norm = myGPR.predict(train_X, train_RBD_joint2);
    ypred_test_norm = myGPR.predict(test_X, test_RBD_joint2);
end




%% Incremental GPR with Budget and Cholesky update
budget = 600;                  
Sigma_n = 9.16;
Sigma_rbf = 2.19;
Sigma_f = 12.5675;

myCholBudgetGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

% Train incrementally
t = zeros(size(train_X,1),1);
for i=1:size(train_X,1)
    tic
    myCholBudgetGPR = myCholBudgetGPR.update(train_X(i,:), train_y(i), train_RBD_joint2(i));
    t(i)=toc;
end
disp("mean execution time for one new point in Chol is: "+ string(mean(t)))

% Compute alpha
myCholBudgetGPR = myCholBudgetGPR.fit();

% Test model on taining set
[ypred_train,~] = myCholBudgetGPR.predict(train_X,train_RBD_joint2);

% Predict target y using the previously trained GPR model 
[ypred_test,~] = myCholBudgetGPR.predict(test_X,test_RBD_joint2);





%% Incremental GPR with Budget and Sherman-Morisson


myIncBudgetGPR = IncBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

% Train incrementally
t = zeros(size(train_X,1),1);
for i=1:size(train_X,1)
    tic
    myIncBudgetGPR = myIncBudgetGPR.update(train_X(i,:), train_y(i), train_RBD_joint2(i));
    t(i)=toc;
end
disp("mean execution time for one new point in Budget is: "+ string(mean(t)))

% Compute alpha
myIncBudgetGPR = myIncBudgetGPR.fit();

% Test model on taining set
[ypred_train2,~] = myIncBudgetGPR.predict(train_X,train_RBD_joint2);

% Predict target y using the previously trained GPR model 
[ypred_test2,~] = myIncBudgetGPR.predict(test_X,test_RBD_joint2);





%% Incremental GPR with Random Features
% D = 500;                  % Nb of random features
% dim = size(train_X,2);    % Dimensionality of the data
% Sigma_n = 2.5;
% Sigma_rbf = 1.5;
% Sigma_f = 1;
% 
% myIncGPR = IncRFGPRegressor(D, dim, Sigma_rbf, Sigma_n, Sigma_f);
% 
% % Train incrementally
% t = zeros(size(train_X,1),1);
% for i=1:size(train_X,1)
%     tic
%     myIncGPR = myIncGPR.increment(train_X(i,:), train_y(i), train_RBD_joint2(i));
%     t(i)=toc;
% end
% disp("mean execution time for one new point in RF is: "+ string(mean(t)))
% 
% % Test model on taining set
% ypred_train3 = myIncGPR.predict(train_X,train_RBD_joint2);
% 
% % Predict target y using the previously trained GPR model 
% ypred_test3 = myIncGPR.predict(test_X,test_RBD_joint2);


%% Plotting results

% Sort the data that need to be plotted
[x_plot_train_sorted, idx_train] = sort(x_plot_train);
ypred_train_sorted = ypred_train(idx_train);
train_RBD_joint2_sorted = train_RBD_joint2(idx_train);
if comparison == true
    ypred_train_trad_sorted = ypred_train_norm(idx_train);
    ypred_train2_sorted = ypred_train2(idx_train);
end

% Plot result of the GPR on the train data
figure
plot(x_plot_train, train_y,'b.');
hold on;
plot(x_plot_train_sorted, ypred_train_sorted, 'r');
plot(x_plot_train_sorted, train_RBD_joint2_sorted, 'k');
if comparison == true
    plot(x_plot_train_sorted, ypred_train_trad_sorted, 'm');
    plot(x_plot_train_sorted, ypred_train2_sorted, 'g');
    legend('Data','Chol GPR', 'nominal RBD', 'GPR','Budget GPR');
else
    legend('Data','chol GPR', 'nominal RBD');
end
xlabel('Data number');
ylabel('Torque');
title('GPR on training set')
savefig('IncrementalGPRTrainingSet.fig')
plotbrowser('on')
hold off


% Sort the data that need to be plotted
[x_plot_test_sorted, idx_test] = sort(x_plot_test);
ypred_test_sorted = ypred_test(idx_test);
test_y_sorted = test_y(idx_test);
test_RBD_joint2_sorted = test_RBD_joint2(idx_test);
if comparison == true
    ypred_test_trad_sorted = ypred_test_norm(idx_test);
    ypred_test2_sorted = ypred_test2(idx_test);
end

nn = size(dataTest,1);
% Plot result of the GPR on the train data
figure
plot(x_plot_test_sorted(1:nn), test_y_sorted(1:nn),'b.');
hold on;
plot(x_plot_test_sorted(nn+1:end), test_y_sorted(nn+1:end),'c.');
plot(x_plot_test_sorted, ypred_test_sorted, 'r');
plot(x_plot_test_sorted, test_RBD_joint2_sorted, 'k'); 
if comparison == true
    plot(x_plot_test_sorted, ypred_test_trad_sorted, 'm');
    plot(x_plot_test_sorted, ypred_test2_sorted, 'g');
    legend('Data in training range','Data away','Chol GPR', 'nominal RBD', 'GPR','Budget GPR');
else
    legend('Data in training range','Data away','Chol GPR', 'nominal RBD');
end

xlabel('Data number');
ylabel('Torque');
title('GPR on testing set')
savefig('IncrementalGPRTestingSet.fig')
plotbrowser('on')
hold off
