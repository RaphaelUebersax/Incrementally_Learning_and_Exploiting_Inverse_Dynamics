%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO COMPUTE THE ANALYSE DIFFERENT METHODE OF EXPLORATION IN A 
% CONSTRAINED ENVIRONMENT USING NONPARAMETRIC INCREMENTAL GAUSSIAN PROCESS.
%
% Last edition: 01.11.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
rng('default');

plot_constraint = false;
plot_trajectory = true;
plot_error = true;



%% 1) Create 4d constrained environment

% Sample datapoints as constrained environement

sc = 0.1;
% Constraint 1
m1 = sc*[10;30;5;30];	  %Mean
sigma1 = sc^2*10*eye(4);	  %Variance
d1 = 100;             %Length
z1 = mvnrnd(m1,sigma1,d1);

% Constraint 2
m2 = sc*[25;0;15;0];     %Mean
sigma2 = sc^2*diag([30;5;30;7]);	  %Variance
d2 = 250;             %Length
z2 = mvnrnd(m2,sigma2,d2);

% Constraint 3
m3 = sc*[-25;20;-5;-25];	%Mean
sigma3 = sc^2*diag([6;30;6;30]);	    %Variance
d3 = 300;               %Length
z3 = mvnrnd(m3,sigma3,d3);

if plot_constraint
    figure 
    scatter(z1(:,1),z1(:,2))
    hold on
    scatter(z2(:,1),z2(:,2))
    scatter(z3(:,1),z3(:,2))
    xlabel("q1")
    ylabel("q2")
    title("Task Constraints - Positions")
    
    figure 
    scatter(z1(:,3),z1(:,4))
    hold on
    scatter(z2(:,3),z2(:,4))
    scatter(z3(:,3),z3(:,4))
    xlabel("q1dot")
    ylabel("q2dot")
    title("Task Constraints - Velocities")
    
end
 

% Use two sines as prior and ground truth of the torque   
RBD = @(A) 1.2*sin(sum(A,2)/50*pi);
y = @(A) 2.3*sin(sum(A,2)/50*pi);


%% 2) Model the constrained with ML technique

X = [z1;z2;z3];
gm = fitgmdist(X,3);

% For verification
ComponentMeans = gm.mu;
ComponentCovariances = gm.Sigma;


%% 3) Use Incremental GPR to predict the torque while exploring

% Number of steps
steps = 1500;

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

% Initialize hyperparameters
I_clust = [d1;d2;d3];
robot_step = sc*4;
I_var = 0.25;

% Define staring postion of the "robot"
x_start = [0,0,0,0];

% Initialize trajectory vector for plotting purpose
trajectory = zeros(steps+1,4);
trajectory(1,:) = x_start;

% Iteration 1: First point
x_current = x_start;
myGPR = myGPR.update(x_current, y(x_current), RBD(x_current));
myGPR = myGPR.fit();

% Prediciton error for all point in task constraints
prediction_error = zeros(steps,1);
[ypred, ~] = myGPR.predict(X, RBD(X));
prediction_error(1) = norm(ypred-y(X),2);
proba = zeros(steps,1);
% Train incrementally by balancing exploration and task constraints
for i=1:steps
    
    % Select next point to go to
    [x_current, I_clust,proba(i)] = select_next2(gm, x_current, myGPR, I_clust, robot_step, I_var);
    trajectory(i+1,:) = x_current;
    
    % Increment importance of exploration
    I_var = 0.25+3*i/(4*steps);  

    % Add point to model and compute updated GP incrementally
    myGPR = myGPR.update(x_current, y(x_current), RBD(x_current));
    myGPR = myGPR.fit();

    % Compute error in task domain
    [ypred, ~] = myGPR.predict(X, RBD(X));
    prediction_error(i) = norm(ypred-y(X),2);
    
    

    
    % Display during computation
    if mod(i,100)==0
        disp("Iteration: " + string(i) + "/" + string(steps));
    end
end

%% 4) Compute ideal error by knowing all point beforehand

myGPR1 = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

for i=1:size(X,1)
    myGPR1 = myGPR1.update(X(i,:), y(X(i,:)), RBD(X(i,:)));    
end
myGPR1 = myGPR1.fit();
[ypred2, ~] = myGPR1.predict(X, RBD(X));
prediction_error1 = norm(ypred2-y(X),2);

%% 5) Plot results

sz = 16;
if plot_trajectory
    figure 
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    plot(trajectory(:,1),trajectory(:,2),'r');
    xlabel("q1",  'FontSize', sz)
    ylabel("q2", 'FontSize', sz)
    title("Task Constraints - Positions", 'FontSize', sz)
    
    figure 
    scatter(z1(:,3),z1(:,4))
    hold on
    scatter(z2(:,3),z2(:,4))
    scatter(z3(:,3),z3(:,4))
    plot(trajectory(:,3),trajectory(:,4),'r');
    xlabel("q1dot", 'FontSize', sz)
    ylabel("q2dot", 'FontSize', sz)
    title("Task Constraints - Velocities", 'FontSize', sz)
    
    figure 
    scatter(z1(:,1),z1(:,3),'b')
    hold on
    scatter(z2(:,1),z2(:,3),'b')
    scatter(z3(:,1),z3(:,3),'b')
    plot(trajectory(:,1),trajectory(:,3),'r');
    xlabel("q1")
    ylabel("q1dot")
    title("Task Constraints - Positions/Velocities")
    
    figure 
    scatter(z1(:,2),z1(:,4),'b')
    hold on
    scatter(z2(:,2),z2(:,4),'b')
    scatter(z3(:,2),z3(:,4),'b')
    plot(trajectory(:,2),trajectory(:,4),'r');
    xlabel("q2")
    ylabel("q2dot")
    title("Task Constraints - Positions/Velocities")
    
end

if plot_error
    figure 
    plot(1:length(prediction_error),prediction_error,'k');
    hold on
    %plot(linspace(1,length(prediction_error),2),ones(2,1)*prediction_error1,'r')
    xlabel("Number of steps", 'FontSize', sz)
    ylabel("Error in Torque [Nm]", 'FontSize', sz)
    title("Error of unconstraint model",  'FontSize', sz)
end
    
%% 6)

y_truth =y(X);
rbd = RBD(X);
nb = 100;

figure
plot(1:nb,ypred(1:nb),'k-o')
hold on
plot(1:nb,y_truth(1:nb),'b')
plot(1:nb, rbd(1:nb),'g')
legend("predicted2","truth", "RBD")