classdef I_SSGPRegressor
    
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %
   % CLASS OBJECT IMPLENTATION THE I-SSGPR ALGORITHM (RANDOM FEATURES BASED
   % APPROACH) OF THE GPR ALGORITHM.
   %
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
   % Definition of all attribute for this class
   properties
      Sigma_n_         % Noise added to the GPR model 
      Sigma_f_         % Covariance noise of the RBF kernel
      Gamma_           % Lengthscale coefficient of the RBF kernel
      D_               % Number of random features to use
      R_               % Cholesky matrix of the Gram Matrix
      Omega_           % Matrix drawn from a normal distribution 
      N_               % Input data dimension
      B_               % Incremental updated vector
      w_               % Incremental updated vector
      
      
   end
   
   
   methods
       
      % Constructor of the class to assign input values to properties
      function obj = I_SSGPRegressor(D,dimension, Sigma_rbf, Sigma_n, Sigma_f)
         if nargin == 5
            obj.D_ = D;
            obj.N_ = dimension;
            obj.Sigma_n_ = Sigma_n^2;
            obj.Gamma_ = 1/(Sigma_rbf^2);
            obj.Sigma_f_ = Sigma_f;
            
         else
             msg = "Wrong number of input parameters for this class!";
             msg = msg + newline + newline + "RequiredInputs are:";
             msg = msg + newline + "   1) D         (int): number of random features";
             msg = msg + newline + "   2) dimension (int): dimension of x";
             msg = msg + newline + "   3) Sigma_rbf (double): RBF kernel lengthscale";
             msg = msg + newline + "   4) Sigma_n   (double): Noise added to incremental GPR";
             msg = msg + newline + "   5) Sigma_f   (double): Factor of RBF kernel";
             error(msg)
         end
         
         % Initializations
         obj.R_ = obj.Sigma_n_*eye(2*obj.D_);
         obj.w_ = zeros(2*obj.D_,1);
         obj.B_ = zeros(2*obj.D_,1);
         obj.Omega_ = normrnd(0,obj.Gamma_,obj.D_,obj.N_);
        
      end
      
      
      % Incrementing the GPR using Cholesky decompostion and random feature
      % maps for a new given point
      function obj = increment(obj, x, y, f_mean)
         phi = obj.Sigma_f_*sqrt(1/obj.D_)*[cos(obj.Omega_*x'); sin(obj.Omega_*x')];
         obj.B_ = obj.B_ + phi*(y - f_mean);
         obj.R_ = cholupdate([obj.R_],phi);
         obj.w_ = ([obj.R_]\([obj.R_]'\[obj.B_]));
          
      end
      
      
      % Predict the target value for a new input with the GPR
      function [y, var] = predict(obj, X_test, F_mean)
          phi = obj.Sigma_f_*sqrt(1/obj.D_)*[cos(obj.Omega_*X_test'); sin(obj.Omega_*X_test')];
          y = F_mean' + [obj.w_]'*phi;
          y = y';
          v = [obj.R_]'\phi;
          var = [obj.Sigma_n_]^2*(ones(size(v,2),1)+diag(v'*v));     
      end
      
      % Computing the gradient of the variance for exploration purpose
      function [grad_var] = gradient_var(obj, x_test)
          p = [cos(obj.Omega_*x_test'); sin(obj.Omega_*x_test')];
          grad_a = [[obj.Omega_].*cos(obj.Omega_*x_test'); [obj.Omega_].*sin(obj.Omega_*x_test')];
          q = [obj.R_]\([obj.R_]'\p);
          grad_var = (2*[obj.Sigma_n_]^2*[obj.Sigma_f_]^2)/[obj.D_]*grad_a'*q;
          grad_var = grad_var';
          if norm(grad_var,2)~=0
              grad_var = grad_var/norm(grad_var,2);
          end
      end
      
   end
end