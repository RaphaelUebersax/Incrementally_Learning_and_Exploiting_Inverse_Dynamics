classdef BlockInvBudgetGPRegressor
    
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %
   % CLASS OBJECT IMPLENTATION THE BLOCK-BASED INVERSION FORMULA TO COMPUTE 
   % GP REGRESSOR INCREMENTALLY
   %
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   
   % Definition of all attribute for this class
   properties
      Sigma_n_         % Noise added to the GPR model 
      Sigma_f_         % Covariance noise of the RBF kernel
      Sigma_rbf_       % Lengthscale coefficient of the RBF kernel
      Budget_          % Maximum number of datapoints in Kernel
      K_noise_         % Gram Matrix with noise (K+sigma_n^2*I)
      K_inv_           % Inverse of K_noise
      X_train_         % Datapoint in training set considered
      y_train_         % Target of training data
      F_mean_train_    % Mean of training data
      Alpha_           % Weight coefficient
            
   end
   
   
   methods
       
      % Constructor of the class to assign input values to properties
      function obj = BlockInvBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f)
         if nargin == 4
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = Sigma_f;
            
         elseif nargin == 3
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = 1;
         else
             msg = "Wrong number of input parameters for this class!";
             msg = msg + newline + newline + "RequiredInputs are:";
             msg = msg + newline + "   1) Budget    (int): Max number of datapoints";
             msg = msg + newline + "   2) Sigma_rbf (double): RBF kernel lengthscale";
             msg = msg + newline + "   3) Sigma_n   (double): Noise added to incremental GPR";
             error(msg)
         end
                  
      end
      
      
      % Main function to check if add new point to model or not
      function obj = update(obj, x, y, f_mean)
              
          if size(obj.X_train_,1) < obj.Budget_
              obj = obj.increment(x, y, f_mean);
          else
              index = obj.check_similarity(x);
              if index ~= (obj.Budget_+1)
                  obj = obj.decrement(index);
                  obj = obj.increment(x,y,f_mean);
              end
          end
          
      end
      
      
      % Find index of datapoint with the least information
      function idx = check_similarity(obj,x)
             b = obj.RBF_kernel_star(x)';
             c = obj.RBF_kernel(x);
             Gram = [obj.K_noise_, b; b', c];
             [~,idx] = max(mean(Gram,1));
      end
      
      
      % Compute the kernel k(X_train,x_test) datapoint wise
      function K_star = RBF_kernel_star(obj, X_test)
          nms = -1*pdist2(X_test,obj.X_train_,'squaredeuclidean');
          K_star = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*nms);
      end
      
      
      % Computes the Gram Matrix for the input X
      function K = RBF_kernel(obj,X)
          nms = -1*pdist2(X,X,'squaredeuclidean');
          K = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*nms);
      end
      

      
      % Incrementing the GPR model
      function obj = increment(obj, x, y, f_mean)
         if isempty(obj.X_train_)
            obj.K_noise_ = [obj.Sigma_f_]^2+[obj.Sigma_n_]^2;
            obj.K_inv_ = 1/obj.K_noise_;
            obj.X_train_ = x;
            obj.y_train_ = y;
            obj.F_mean_train_ = f_mean;
            
         else 
             % update the (K+sigma_n^2I) matrix
             b = obj.RBF_kernel_star(x)';
             c = obj.RBF_kernel(x)+[obj.Sigma_n_]^2;
             obj.K_noise_ = [obj.K_noise_, b; b', c];
             
             % update the (K+sigma_n^2I)^(-1) matrix
             d = c-b'*obj.K_inv_*b;
             a1 = obj.K_inv_ + 1/d*obj.K_inv_*b*b'*obj.K_inv_;
             a2 = -1/d*obj.K_inv_*b;
             a3 = -1/d*b'*obj.K_inv_;
             a4 = 1/d;
             obj.K_inv_ = [a1,a2;a3,a4];
             
             % update the training set
             obj.X_train_ = [obj.X_train_;x];
             obj.y_train_ = [obj.y_train_;y];
             obj.F_mean_train_ = [obj.F_mean_train_;f_mean];
             
         end
                 
      end
      
      
      % Decrement the matrix to be able to add the new point
      function obj = decrement(obj,index)
          if index ~= obj.Budget_
              % Swap rows/columns of K and Kinv
              
              obj.K_noise_([index,end],:)=obj.K_noise_([end,index],:);
              obj.K_noise_(:,[index,end])=obj.K_noise_(:,[end,index]);
              
              obj.K_inv_([index,end],:)=obj.K_inv_([end,index],:);
              obj.K_inv_(:,[index,end])=obj.K_inv_(:,[end,index]);
              
              % Swap data in train
              obj.X_train_([index end], :) = obj.X_train_([end index], :);
              obj.y_train_([index end]) = obj.y_train_([end index]);
              obj.F_mean_train_([index end]) = obj.F_mean_train_([end index]);
          end
          
          % Block matrices required
          c = obj.K_noise_(end,end);
          b = obj.K_noise_(end,1:end-1)';
          D = obj.K_inv_(1:end-1,1:end-1);
          
          % update K_noise
          obj.K_noise_ = obj.K_noise_(1:end-1,1:end-1);
          
          % update K_inv
          obj.K_inv_ = D-(D*b*(D*b)')/(c+b'*D*b);
          
          % update training data
          obj.X_train_ = obj.X_train_(1:end-1,:);
          obj.y_train_ = obj.y_train_(1:end-1);
          obj.F_mean_train_ = obj.F_mean_train_(1:end-1);
          
      end
      
      
      
      % Used the training data to compute alpha
      function obj = fit(obj)
         obj.Alpha_ = obj.K_inv_*(obj.y_train_-obj.F_mean_train_);
      end
      
      % Predict the target value for a new input with the GPR
      function [y, Var] = predict(obj, X_test, F_mean)
          K_star = obj.RBF_kernel_star(X_test);
          y = F_mean + K_star*obj.Alpha_;
          Var = diag(obj.RBF_kernel(X_test)-K_star*[obj.K_inv_]*K_star');
      end
      
      
      
      % Compute gradient of variance
      function [grad_var] = gradient_var(obj, x_test)
          K_star = obj.RBF_kernel_star(x_test);
          w = 1/[obj.Sigma_rbf_]^2*K_star'.*(x_test-obj.X_train_);
          grad_var = 2*K_star*v*obj.K_inv_*w;
          if norm(grad_var)~=0
            grad_var = grad_var/norm(grad_var);
          end
      end
      
   end
end