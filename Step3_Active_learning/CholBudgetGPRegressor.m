classdef CholBudgetGPRegressor
    
   % Definition of all attribute for this class
   properties
      Sigma_n_         % Noise added to the GPR model 
      Sigma_f_         % Covariance noise of the RBF kernel
      Sigma_rbf_       % Lengthscale coefficient of the RBF kernel
      Budget_          % Maximum number of datapoints in Kernel
      R_noise_         % Cholesky factor of Gram Matrix with noise chol(K+sigma_n^2*I)
      X_train_         % Datapoint in training set considered
      y_train_         % Target of training data
      F_mean_train_    % Mean of training data
      Alpha_           % Weight coefficient
            
   end
   
   
   methods
       
      % Constructor of the class to assign input values to properties
      function obj = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f)
         if nargin == 4
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = Sigma_f;
            
         elseif nargin == 3
            obj.Budget_ = budget;
            obj.Sigma_n_ = Sigma_n;
            obj.Sigma_rbf_ = Sigma_rbf;
            obj.Sigma_f_ = 1;
         else
             msg = "Wrong number of input parameters for this class!";
             msg = msg + newline + newline + "RequiredInputs are:";
             msg = msg + newline + "   1) Budget    (int): Max number of datapoints";
             msg = msg + newline + "   2) Sigma_rbf (double): RBF kernel lengthscale";
             msg = msg + newline + "   3) Sigma_n   (double): Noise added to incremental GPR";
             error(msg)
         end
                  
      end
      
      
      % Main function to check if add new point to model or not
      function obj = update(obj, x, y, f_mean)
              
          if size(obj.X_train_,1) < obj.Budget_
              obj = obj.increment(x, y, f_mean);
          else
              index = obj.check_similarity(x);
              if index ~= (obj.Budget_+1)
                  obj = obj.decrement(index);
                  obj = obj.increment(x,y,f_mean);
              end
          end
          
      end
      
      
      % Find index of datapoint with the least information
      function idx = check_similarity(obj,x)
             b = obj.RBF_kernel_star(x)';
             c = obj.RBF_kernel(x);
             Gram = [obj.R_noise_'*obj.R_noise_, b; b', c];
             [~,idx] = max(mean(Gram,1));
      end
      
      
      % Compute the kernel k(X_train,x_test) datapoint wise
      function K_star = RBF_kernel_star(obj, X_test)
          nms = -1*pdist2(X_test,obj.X_train_,'squaredeuclidean');
          K_star = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*nms);
      end
      
      % Computes the Gram Matrix for the input X
      function K_noise = RBF_kernel(obj,X)
          nms = -1*pdist2(X,X,'squaredeuclidean');
          K = [obj.Sigma_f_]^2*exp(1/(2*[obj.Sigma_rbf_]^2)*nms);
          K_noise = K + [obj.Sigma_n_]^2*eye(size(X,1));
      end
      
      % Incrementing the GPR model
      function obj = increment(obj, x, y, f_mean)
         if isempty(obj.X_train_)
            obj.R_noise_ = [obj.Sigma_f_]^2;
            obj.X_train_ = x;
            obj.y_train_ = y;
            obj.F_mean_train_ = f_mean;
            
         else 
             % update the R matrix
             a = obj.R_noise_'\obj.RBF_kernel_star(x)';
             b = sqrt(obj.RBF_kernel(x)-a'*a);
             obj.R_noise_ = [obj.R_noise_,a;zeros(1,length(a)),b];
             
             % update the training set
             obj.X_train_ = [obj.X_train_;x];
             obj.y_train_ = [obj.y_train_;y];
             obj.F_mean_train_ = [obj.F_mean_train_;f_mean];
             
         end
                 
      end
      
      
      % Decrement the matrix to be able to add the new point
      function obj = decrement(obj,index)
          if index ~= obj.Budget_
              % Compute decremented cholesky factor R
              w = [zeros(1,index),obj.R_noise_(index,index+1:end)]';   % update vector depending on index
              obj.R_noise_ = cholupdate(obj.R_noise_,w);               % rank 1 update
              obj.R_noise_(index,:) = [];                          % delete non-desired row
              obj.R_noise_(:,index) = [];                          % delete non-desired column
                            
          else
              obj.R_noise_ = obj.R_noise_(1:end-1,1:end-1);    
          end
          
          % delete training data
          obj.X_train_(index, :) = [];
          obj.y_train_(index) = [];
          obj.F_mean_train_(index) = [];
                   
      end
      
      
      
      % Used the training data to compute alpha
      function obj = fit(obj)
         obj.Alpha_ = obj.R_noise_\(obj.R_noise_'\(obj.y_train_-obj.F_mean_train_));
      end
      
      % Predict the target value for a new input with the GPR
      function [y, Var] = predict(obj, X_test, F_mean)
          K_star = obj.RBF_kernel_star(X_test);
          y = F_mean + K_star*obj.Alpha_;
          v = obj.R_noise_'\K_star';
          Var = diag(obj.RBF_kernel(X_test) - v'*v);
      end
      
      
      % Compute gradient of variance
      function [grad_var] = gradient_var(obj, x_test)
          K_star = obj.RBF_kernel_star(x_test);
          w = 1/[obj.Sigma_rbf_]^2*K_star'.*(x_test-obj.X_train_);
          v = obj.R_noise_\(obj.R_noise_'\w);
          grad_var = 2*K_star*v;
          if norm(grad_var)~=0
            grad_var = grad_var/norm(grad_var);
          end
      end
      
   end
end