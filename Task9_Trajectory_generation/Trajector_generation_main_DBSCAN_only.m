%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO GENERATE REAL SET OF TRAJECTORIES BASED BASED ON A SPECIFIC
% TASK OF THE ROBOT. IT THEN EXPLORES THE TASK REGION USING THE PREVIOUSLY
% DEVELOPPED ONLINE TECHNIQUE BASED ON LIMIT CYCLES
%
% Last edition: 15.12.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
addpath("./Task9_tools");
rng('default');

% Setup python environment with anaconda and windows
setup_conda();

% Compute metrics
do_prediction_accuracy = false;
do_variance_computation = false;


% Info variables to plot

plot_trajectory = true;
plot_x_n = true;
plot_constraint = true;
plot_error = false;
plot_RBD = false;
plot_limit_cycles = false;




%% 0) Variables and constraints

% Select one task
%Task = "Polar_DS";      % "Linear_DS", "Polar_DS"
Task = "Linear_DS";

% Feasibility constraint in x-domain (3D)
Task_region.upper_bound = [0.75,0.75,0.75];
Task_region.lower_bound = [0.25,0.25,0.25];

% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];


%% 1) Define RBD dynamic function

RBD_torque = @(robot, q, qdot) inverseDynamics(robot, q, qdot, zeros(1,7));


%% 2) Import results from data folder

if strcmp(Task,"Linear_DS")
    data_q = load("data/Linear_DS_qs.mat");
    data_q = data_q.data_q;
    data_x = load("data/Linear_DS_xs.mat");
    data_x = data_x.data_x;
    nb_gaussians = [1,2,2,2,2,3,1];
    
    % DBSCAN Hyperparameters
    epsilon = 0.22;
    minpts = 10;
    min_points_per_region = 75;
    
    
elseif strcmp(Task,"Polar_DS")
    data_q = load("data/Polar_DS_qs.mat");
    data_q = data_q.data_q;
    data_x = load("data/Polar_DS_xs.mat");
    data_x = data_x.data_x;
    nb_gaussians = [1,2,1,2,1,2,1];
    
    % DBSCAN Hyperparameters
    epsilon = nan;
    minpts = nan;
    min_points_per_region = 75;
end



%% 3) Model the constrained region with GMM and rotation order
point_in_regions = cell(7,1);
figure
title("DBSCAN")
for idx=1:7
    nComponents = nb_gaussians(idx);
    X = [data_q(:,idx),data_q(:,7+idx)];

    % Perform DBSCAN to cluster the regions
    cluster_idx = dbscan(X,epsilon,minpts);
    
    % Find number of regions
    labels = unique(cluster_idx);
    if labels(1) == -1
        labels = labels(2:end);
    end
    
    idx_to_delete = [];
    for j=1:length(labels)
        if sum(cluster_idx==j) < min_points_per_region
            idx_to_delete = [idx_to_delete, j];
        end
    end
    labels(idx_to_delete) = [];
    nb_regions = length(labels);
    data_regions = cell(nb_regions,1);
    
    % Store data of each cluster
    for jj =1:nb_regions
        data_regions{jj} = X(cluster_idx==labels(jj),:);
    end
    
    % store clustering of joint 1
    point_in_regions{idx} = data_regions;

    ax(idx) = subplot(4,2,idx);
    scatter(X(:,1),X(:,2),'*');
    hold on
    for k=1:nb_regions
       scatter(X(cluster_idx==labels(k),1),X(cluster_idx==labels(k),2),...
           'MarkerFaceAlpha',.4,'MarkerEdgeAlpha',.4);
    end
    xlabel("q"+string(idx))
    ylabel("q"+string(idx)+"dot")
   
end



% % Determine rotation order of the regions
% angle_from_center = atan2(gm.mu(:,2),gm.mu(:,1));
% for i=1:nb_gaussians
%     if angle_from_center(i) < 0
%         angle_from_center(i) = angle_from_center(i) + 2*pi;
%     end
% end
% [~,rotation_order_idx] = sort(angle_from_center,'descend');
% 
 
%% 5) Setup feasibility constraints in (q,dot)

% Get joint constraints from urdf file
jointConst = constraintJointBounds(robot);
jointConst = jointConst.Bounds;

% Physical limits of the joint
feasibility.q_upper_bound = jointConst(:,2);
feasibility.q_lower_bound = jointConst(:,1);
feasibility.qdot_upper_bound = 6;
feasibility.qdot_lower_bound = -6;
feasibility.margin = 0.1;


%% 6) Define parameters and init Incremental GPR 

% Structure containing parameters of optimization
param = {};
params.I_var = 2;               % Importance of the variance
params.traj_iter = 2;           % Index of the trajectory
params.region_thres = 2.5;      % Nb of "sigma" that is considered to be in region
params.robot_step = 0.05;        % Size of the step for computing the next point
params.convergence_dist = 0.1;  % Distance to be close enough to goal
params.delta_T = 0.01;          % update frequency of robot (min: 0.005)
params.alpha = 0.95;             % convergence rate for rho
params.beta = 0.5;              % Convergence rate for theta
params.sparseness = 10;         % Add point of trajectory all n iterations
params.P = 20;                  % Number of random points for select method number 2  
params.M = 3;                   % Number of step from random points for select method number 3&4
params.N = 20;                  % Number of random directions for select method 3

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);


%% 7) Initialization of the joint position and goals in each region
% 
% % Number of steps
% steps = 5;
% 
% % Define staring postion of the "robot"
% x_start = [4,0];
% 
% % Initialize trajectory vector for plotting purpose
% trajectory = zeros(1,2);
% trajectory(1,:) = x_start;
% 
% % Initialize the goal of each region to be the center of the region
% X_next = gm.mu;     % (nb_gaussians x N)
% 
% %qc_center = mean(gm.mu(:,1));
% qc_center = 0;
% feasibility.qc_center = qc_center;
% 
% 
% 
% %% 8) First iteration
% 
% % First point
% x_current = x_start;
% 
% % Compute limit cylce passing through each "next" point in region
% [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);
% 
% 
% 
% if plot_limit_cycles
%     figure
%     scatter(z1(:,1),z1(:,2),'b')
%     hold on
%     scatter(z2(:,1),z2(:,2),'b')
%     scatter(z3(:,1),z3(:,2),'b')
%     th = 0:pi/50:2*pi;
%     for i = 1:3
%         xunit = opt_rho(i) * cos(th) + opt_qc(i);
%         yunit = opt_rho(i) * sin(th);
%         h = plot(xunit, yunit,'m');
%     end
% end
% 
% 
% 
% % Compute first trajectory of the limit cycle
% [points_to_add, x_current, trajectory, params] = complete_trajectory2(opt_rho, ...
%     opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
% 
% % Add point to model and compute updated GP incrementally
% for j=1:size(points_to_add,1)
%     myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
% end
% myGPR = myGPR.fit();
% 
% 
% 
% % Compute prediction error in task domain
% if do_prediction_accuracy
%     prediction_error = zeros(steps,1);
%     [ypred, ~] = myGPR.predict(X, RBD(X));
%     prediction_error(1) = norm(ypred-y(X),2);
% end
% 
% % Compute the overall variance evolution in the regions
% if do_variance_computation
%     variance_region = zeros(steps,1);
%     [~,yVar] = myGPR.predict(X,false);
%     variance_region(1) = sum(abs(yVar));
% end
% 
% 
% 
% %% 9) Loop over main that balances exploration and exploitation
% 
% x_n_visualize = zeros(3*steps,2);
% 
% % Train incrementally by balancing exploration and task constraints
% for i=1:steps
%     
%     % Select next point to go to 
%     [X_next,params] = select_next_in_region3(gm, X_next, myGPR, feasibility, params);
%     for j=1:3
%         x_n_visualize(3*(i-1)+j,:) = X_next(j,:);
%     end
%     
%     % Create limit cycles to go to the point
%     [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);
%     
%         
%     % move along limit cycles until reaching destination (2pi rotation)
%     [points_to_add, x_current, trajectory, params] = complete_trajectory2(opt_rho, ...
%         opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
%     
%     
%     % Increment importance of exploration
%     params.I_var = 0.25+3*i/(4*steps);
%      
% 
%     % Add point to model and compute updated GP incrementally
%     for j=1:size(points_to_add,1)
%         myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
%     end
%     myGPR = myGPR.fit();
% 
%     % Compute error in task domain
%     if do_prediction_accuracy
%         [ypred, ~] = myGPR.predict(X, RBD(X));
%         prediction_error(i) = norm(ypred-y(X),2);
%     end
%     
%     % Compute the overall variance evolution in the regions
%     if do_variance_computation
%         [~,yVar] = myGPR.predict(X, false);
%         variance_region(i) = sum(abs(yVar));
%     end
%     
% 
%     % Display during computation
%     if mod(i,1)==0
%         disp("Iteration: " + string(i) + "/" + string(steps));
%     end
% end
% 
% 
% 
% %% 10) Plot results
% 
% 
% if plot_trajectory
%     sz = 2;
%     if not(plot_limit_cycles)
%         figure 
%     end
%     scatter(z1(:,1),z1(:,2),'b')
%     hold on
%     scatter(z2(:,1),z2(:,2),'b')
%     scatter(z3(:,1),z3(:,2),'b')
%     plot(trajectory(:,1),trajectory(:,2),'k');
%     plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
%         [feasibility.qdot_upper_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
%     plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
%         [feasibility.qdot_lower_bound,feasibility.qdot_lower_bound],'r','LineWidth',sz);
%     plot([feasibility.q_lower_bound,feasibility.q_lower_bound],...
%         [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
%     plot([feasibility.q_upper_bound,feasibility.q_upper_bound],...
%         [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
%     xlabel("q1")
%     ylabel("q1dot")
%     xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
%     ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
%     title("Task Constraints - Positions/Velocities")
%         
% end
% 
% 
% 
% if plot_x_n
%    figure 
%     scatter(z1(:,1),z1(:,2),'b')
%     hold on
%     scatter(z2(:,1),z2(:,2),'b')
%     scatter(z3(:,1),z3(:,2),'b')
%     scatter(x_n_visualize(:,1),x_n_visualize(:,2),'r')
%     xlabel("q1")
%     ylabel("q1dot")
%     xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
%     ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
% end
% 
% 
% if do_prediction_accuracy
%     if plot_error
%         figure 
%         plot(1:length(prediction_error),prediction_error,'k');
%         hold on
%         %plot(linspace(1,length(prediction_error),2),ones(2,1)*prediction_error1,'r')
%         xlabel("Number of steps")
%         ylabel("Error in Torque")
%         title("Error of constrained model")
%     end
% 
%     if plot_RBD
%         y_truth =y(X);
%         rbd = RBD(X);
%         nb = 100;
% 
%         figure
%         plot(1:nb,ypred(1:nb),'k-o')
%         hold on
%         plot(1:nb,y_truth(1:nb),'b')
%         plot(1:nb, rbd(1:nb),'g')
%         legend("predicted2","truth", "RBD")
%     end
% end
% 
% 
% 
% if do_variance_computation
%     if plot_error
%         figure 
%         plot(1:length(variance_region),variance_region,'k');
%         hold on
%         xlabel("Number of steps")
%         ylabel("Variance in regions")
%         title("Variance of constrained model")
%     end
% end