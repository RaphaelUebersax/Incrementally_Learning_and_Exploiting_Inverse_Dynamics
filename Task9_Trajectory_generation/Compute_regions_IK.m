%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO GENERATE REAL SET OF TRAJECTORIES BASED BASED ON A SPECIFIC
% TASK OF THE ROBOT.
%
% Last edition: 12.12.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

rng('default');
addpath("./Task9_tools");

plot_task_domain = true;

%% 0) Variables and constraints

% Select one task
Task = "Polar_DS";      % "Linear_DS", "Polar_DS"
%Task = "Linear_DS";

data_name = "data/"+ Task + "_qs.mat";
data_name2 = "data/"+ Task + "_xs.mat";

% Feasibility constraint in x-domain (3D)
Task_region.upper_bound = [0.75,0.75,0.75];
Task_region.lower_bound = [0.25,0.25,0.25];

% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];





%% Create points belonging to a specific task (x, xdot)

% Define a task for the robot x-space 

% Linear DS considers x to be 3D and be attracted by goal linearly
if strcmp(Task,"Linear_DS")
    goal = [0.5,0.5,0.5];
    alpha = -1; 
    Task_region.integration_time = 0.1;
    nb_trajectories = 100;
    nb_points_per_traj = 50;
    f = @(x) (alpha*eye(length(x))*(x-goal)')';
    
% Polar DS considers X is moving in a plane with constant limit cycle
elseif strcmp(Task,"Polar_DS")
    rho_0 = 0.1;
    M = 2;
    R = 0.02;
    x_center = [0.5,0.5,0.5];
    Task_region.integration_time = 0.1;
    nb_trajectories = 100;
    nb_points_per_traj = 100;
    f = @(x) Polar_DS_f(x, M, R, rho_0, x_center);
        
else
    error("Select one existing Task")
end
 

% Generate trajectories
X = zeros(nb_trajectories*nb_points_per_traj,3);

% Lower and upper-bound
LB = Task_region.lower_bound;
UB = Task_region.upper_bound;
if strcmp(Task,"Polar_DS")
    rho_max = min([abs(LB(1)-x_center(1)), abs(UB(1)-x_center(1)), ...
                        abs(LB(2)-x_center(2)), abs(UB(2)-x_center(2))]);
    rho_min = 0.02;
                    
end



% Inverse kinematics solver
gik = generalizedInverseKinematics('RigidBodyTree', robot, ...
    'ConstraintInputs', {'position','joint','orientation'});


q = zeros(nb_trajectories*(nb_points_per_traj-1),7);
q_dot = zeros(nb_trajectories*(nb_points_per_traj-1),7);

% Joint limit bounds
jointLimBounds = constraintJointBounds(gik.RigidBodyTree);
jointLimBounds.Weights = ones(1,size(gik.RigidBodyTree.homeConfiguration,2))*10;

fixOrientation = constraintOrientationTarget('iiwa_link_ee');
fixOrientation.OrientationTolerance = deg2rad(1);

% Target constraint
positionTarget = constraintPositionTarget('iiwa_link_ee');
positionTarget.PositionTolerance = 1e-6;
positionTarget.Weights = 1;


iteration = 1;

for i=1:nb_trajectories
    for j=1:nb_points_per_traj
        
        disp("Traj: " + string(i) + ",  Point: " +string(j))
        
        % Initialize x_task randomly in the region of interest
        if j==1
            NotFound = true;
            while(NotFound)
                % Initialize randomly point in task region
                if strcmp(Task,"Linear_DS")
                   x_task = LB + (UB-LB).*rand(1,3);

                elseif strcmp(Task,"Polar_DS")
                   rho = rho_min + (rho_max-rho_min)*rand(1,1);
                   theta = 2*pi*rand(1,1);
                   x_task = [x_center(1)+rho*cos(theta),x_center(2)+rho*sin(theta),x_center(3)];
                   
                end

                % Store x_task
                X(j+nb_points_per_traj*(i-1),:) = x_task;
                positionTarget.TargetPosition = x_task'; 

                % Compute corresponding initial q
                iniGuess = homeConfiguration(robot);
                [opt_q, solutionInfo] = gik(iniGuess,positionTarget,jointLimBounds,fixOrientation);
                q_act = opt_q;
                
                % Check if x_task is correct
                transform = getTransform(robot, q_act,'iiwa_link_ee');
                x_task_comp = transform(1:3,4);
                diff = norm(x_task_comp'-x_task);
                if norm(x_task_comp'-x_task)<= 1e-3
                    NotFound = false;
                end
            end
            
        else
            % 0) Store previous results for better readibility
            x_task_prev = X(j-1+nb_points_per_traj*(i-1),:);
            q_prev = q_act;
            
            % 1) Compute xdot using the dynamical system DS on previous x
            x_task_dot = f(x_task_prev);

            % 2) Compute qdot by solving the inverse kinematics
            jacobian = geometricJacobian(robot,q_prev,'iiwa_link_ee');
            xdot = [0;0;0;x_task_dot'];
            
            
            solver.name = "Damping";  
            opt_qdot = inverseKinematicsSolver(xdot, jacobian, solver);
            
%             solver2.name = "Optimization";
%             solver2.gik = gik;
%             opt_qdot = inverseKinematicsSolver(xdot, jacobian, solver2);
       

            q_dot(iteration,:) = opt_qdot;

            % 3) Compute q by integrating q and store result of q
            q_act = q_prev + opt_qdot * Task_region.integration_time;
            q(iteration,:) = q_act;

            % 4) Compute x by forward kinematics
            transform = getTransform(robot, q_act, 'iiwa_link_ee');
            x_task = transform(1:3,4);
            
            % 5) Store result of x
            X(j+nb_points_per_traj*(i-1),:) = x_task';
            
            % Increment iter
            iteration = iteration + 1;
            
        end 

    end
         
    
end

% Remove all zeros lines of q (Initial points of traj, where no qdot can be
% computed)
% q_dot = q_dot(any(q,2),:);
% q = q(any(q,2),:);

%% Save data


data_q = [q,q_dot];
data_x = X;
save(data_name,'data_q');
save(data_name2,'data_x');


%% PLOT OF Q QDOT


if plot_task_domain
    if strcmp(Task,"Linear_DS")
        figure
        plot3(0.5,0.5,0.5,'o')
        hold on
        %xlim([Task_region.lower_bound(1),Task_region.upper_bound(1)])
        %ylim([Task_region.lower_bound(2),Task_region.upper_bound(2)])
        %zlim([Task_region.lower_bound(3),Task_region.upper_bound(3)])
        xlabel("X")
        ylabel("Y")
        zlabel("Z")
        for k=1:nb_trajectories
            i_s = 1+(k-1)*nb_points_per_traj;
            i_end = i_s + nb_points_per_traj-1;
            plot3(X(i_s:i_end,1),X(i_s:i_end,2),X(i_s:i_end,3))
        end
    elseif strcmp(Task,"Polar_DS")
        figure
        plot(0.5,0.5,'o')
        hold on
        xlabel("X")
        ylabel("Y")
        for k=1:nb_trajectories
            i_s = 1+(k-1)*nb_points_per_traj;
            i_end = i_s + nb_points_per_traj-1;
            plot(X(i_s:i_end,1),X(i_s:i_end,2))
        end
    end
end


figure
title("Task space analysis")
for idx =1:6
    ax(idx) = subplot(3,2,idx);
    scatter(q(:,idx),q_dot(:,idx),'*')
    xlabel("q"+string(idx))
    ylabel("q"+string(idx)+"dot")
end

% linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'x')
% linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'y')


