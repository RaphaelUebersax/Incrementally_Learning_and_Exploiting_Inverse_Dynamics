function [points_to_add, q_current, trajectory, params] = complete_trajectory(rho, ...
    qc, q_current, Q_next, gm, params, trajectory)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION "MOVES" ALONG THE LIMIT CYCLE WHILE COLLECTING DATA OF THE
% REGIONS OF INTEREST UNTIL IT REACHES ZERO VELOCITY AGAIN. THIS ONE USES
% CONVERGENCE CRITERION BASED ON DISTANCE, AND IS MORE APPROPRIATE FOR
% COMPLETE TRAJECTORY THAT CANNOT BE PERFORMED IN ONE ROTATION ONLY.
%
% Input: - rho                 : (cell(7,1)) Radius of limit cycles
%        - qc                  : (cell(7,1)) Center of limit cycles 
%        - q_current           : (1 x P) Last considered datapoint of dimension P
%        - Q_next              : (cell(7,1)) Goal datapoint of dimension P
%        - params              : (struct) Parameters
%        - trajectory          : (k x P) All points that have been visited
%
%
% Ouput: - points_to_add       : (H x P) Array containing all points to add
%        - q_current           : (1 x P) Last considered datapoint of dimension P
%        - trajectory          : (k x P) All points that have been visited
%        - params              : (struct) Parameters
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Function that computes the Mahalanobis distance
MahaDist = @(x,GMM) sqrt(diag((x-GMM.mu(1,:))*(GMM.Sigma(:,:,1)\(x-GMM.mu(1,:))')));

% Initialization of loop parameters
has_converged = false;
converged = [false,false,false,false,false,false,false];
points_to_add = [];
region_nb = ones(7,1);
sparse_count = zeros(7,1);
last_region = [false,false,false,false,false,false,false];
passed_trough_next = [false,false,false,false,false,false,false];

% Compute rotation order based on next points to go to
rotation = cell(7,1);
for idx=1:7
    Q = Q_next{idx};
    if size(Q,1)==1
        last_region(idx)=true;
        rotation{idx} = 1;
        
    else
        angle_from_center = atan2(Q(:,2),Q(:,1));
        angle_from_center(angle_from_center < 0) = angle_from_center(angle_from_center < 0) + 2*pi;
        [~,rotation_order_idx] = sort(angle_from_center,'descend');
        rotation{idx} = rotation_order_idx;
    end
    
end



while (has_converged == false)
    
    % Start from the idea of not needing to add those points
    pp_to_add = false;
    
    % iterate for each joint
    for idx = 1:7
        
        if converged(idx)
            trajectory(params.traj_iter,[idx,7+idx]) = q_current([idx,7+idx]);
        else
            % Check if arrived at destination in current region
            q_idx_current = q_current([idx,7+idx]);
            Q_idx_next = Q_next{idx};
            q_idx_next = Q_idx_next(rotation{idx}(region_nb(idx)),:);

            if norm(q_idx_current - q_idx_next)<= params.convergence_dist && ...
                (region_nb(idx) ~= length(rotation{idx}))
                region_nb(idx) = region_nb(idx) + 1 ;

            elseif norm(q_idx_current - q_idx_next)<= params.convergence_dist && ...
                (region_nb(idx) == length(rotation{idx}))
                last_region(idx) = true;
                passed_trough_next(idx) = true;
            end


            % Actual cycle of x_current at the begining
            x_center = q_idx_current-[qc{idx}(rotation{idx}(region_nb(idx))),0];
            rho_j = norm(x_center,2);
            theta_j = atan2(x_center(2),x_center(1));


            % Computation of desired radius rho_d and center qc_d
            rho_d = rho{idx}(rotation{idx}(region_nb(idx)));
            qc_d = qc{idx}(rotation{idx}(region_nb(idx)));

            % Convergence rate
            rho_dot_j = -1*params.alpha * (rho_j-rho_d);
            theta_dot_j = -1*params.beta * exp(-params.alpha^2*(rho_j-rho_d)^2);

            % Integreation
            rho_j = rho_j + params.delta_T*rho_dot_j;
            theta_j = theta_j + params.delta_T * theta_dot_j;

            % New point 
            x_prev = q_idx_current;
            q_idx_current(1) = rho_j*cos(theta_j)+qc_d;
            q_idx_current(2) = rho_j*sin(theta_j);
            
            % Store result
            q_current([idx,7+idx]) = q_idx_current;
            trajectory(params.traj_iter,[idx,7+idx]) = q_idx_current;


            % Add point to model if in region
            % find smallest Mahalanobis distance to all clusters
            min_dist = 1e10;
            for k=1:size(Q_idx_next,1)
                M_distance = MahaDist(q_idx_current,gm{idx,k});
                if M_distance < min_dist
                    min_dist = M_distance;
                end
            end

            % If points in one region of interest, add it to the model
            if min_dist < params.region_thres
                if (sparse_count(idx) == params.sparseness) || (sparse_count(idx) == 0)
                    pp_to_add = true;
                    sparse_count(idx) = 1;
                else 
                    sparse_count(idx) = sparse_count(idx)+1;
                end
            else
                sparse_count(idx) = 0;
            end


            % Check if arrived (qdot>=0 and qdot < thres)
            if (q_idx_current(2) <= params.convergence_dist) && (q_idx_current(2) >= 0) && ...
                    (x_prev(2) > q_idx_current(2)) && (passed_trough_next(idx))

                % Stop the trajectory
                converged(idx) = true;
                disp("joint " + string(idx) + " has converged")

                % Set next point to be on horizontal axis (0-velocity)
                q_current([idx,7+idx]) = [q_idx_current(1),0];

            end
        end
    end
    

    
    % Complete list of points to add to the model
    if pp_to_add
        points_to_add = [points_to_add; trajectory(params.traj_iter,:)];
    end
    
    % Increment trajectory
    params.traj_iter = params.traj_iter + 1;
    
    if converged == [true,true,true,true,true,true,true]
        has_converged = true;
    end
    
end

end