
% method
parametrisation = false;
projections = true;

%%
% Parametrisation
if parametrisation
    r = 10;
    phi1 = -linspace(0,2*pi,100);
    phi2 = -linspace(0,pi,100);
    phi3 = -linspace(0,pi,100);
    phi4 = -linspace(0,pi,100);
    phi5 = -linspace(0,pi,100);
    phi6 = -linspace(0,pi,100);
    phi7 = -linspace(0,pi,100);


    x1 = r*cos(phi1);
    x2 = r*sin(phi1).*cos(phi2);
    x3 = r*sin(phi1).*sin(phi2).*cos(phi3);
    x4 = r*sin(phi1).*sin(phi2).*sin(phi3).*cos(phi4);
    x5 = r*sin(phi1).*sin(phi2).*sin(phi3).*sin(phi4).*cos(phi5);
    x6 = r*sin(phi1).*sin(phi2).*sin(phi3).*sin(phi4).*sin(phi5).*cos(phi6);
    x7 = r*sin(phi1).*sin(phi2).*sin(phi3).*sin(phi4).*sin(phi5).*sin(phi6).*cos(phi7);
    x8 = r*sin(phi1).*sin(phi2).*sin(phi3).*sin(phi4).*sin(phi5).*sin(phi6).*sin(phi7);

    X = [x1',x2',x3',x4',x5',x6',x7',x8'];
end


%% Projection
if projections
    has_reached = false;
    n_dim = 2;
    start_point = 5*ones(1,n_dim);
    if n_dim ==2
        goal_point = [-norm(start_point),0];
    else
        goal_point = [-norm(start_point)/sqrt(4),-norm(start_point)/sqrt(4),-norm(start_point)/sqrt(4),norm(start_point)/sqrt(4)];
    end
    r = norm(start_point);
    normal = 2*start_point;
    A_point = start_point;
    P_point = goal_point;
    step = 0.1;
    iter = 1;
    
    X = A_point;
    
    
    while not(has_reached)
        Q_projection = P_point - (P_point-A_point)*normal'/(norm(normal)^2) *normal;
        v = step*(Q_projection-A_point)/norm(Q_projection-A_point);
        M_point = A_point + v;
        
%         for idx = 1:(n_dim/2)
%             % Ensure positive rotation
%             theta_M_point = atan2(M_point(2*(idx-1)+2),M_point(2*(idx-1)+1));
%             theta_A_point = atan2(A_point(2*(idx-1)+2),A_point(2*(idx-1)+1));
%             if theta_M_point < 0
%                 theta_M_point= theta_M_point +2*pi;
%             end
%             if theta_A_point < 0
%                 theta_A_point= theta_A_point +2*pi;
%             end
%             if theta_M_point > theta_A_point
%                 M_point(2*(idx-1)+1:2*(idx-1)+2) = A_point(2*(idx-1)+1:2*(idx-1)+2)-v(2*(idx-1)+1:2*(idx-1)+2);
%             end
%         end
        
        A_point = r* (M_point / norm(M_point));
        normal = 2*A_point;
        X = [X;A_point];
        iter = iter+1;
        
        if (norm(P_point-A_point) <0.1) || iter>500
           has_reached = true; 
        end
    end
end


%% Plots
n_subspace = n_dim/2;

figure
for idx = 1:n_subspace
    ax(idx) = subplot(1,n_subspace,idx);
    scatter(X(:,2*(idx-1)+1),X(:,2*(idx-1)+2),'*');
end