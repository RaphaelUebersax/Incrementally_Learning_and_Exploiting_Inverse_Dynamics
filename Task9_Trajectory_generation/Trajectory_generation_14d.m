%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO GENERATE REAL SET OF TRAJECTORIES BASED BASED ON A SPECIFIC
% TASK OF THE ROBOT. IT THEN EXPLORES THE TASK REGION USING THE PREVIOUSLY
% DEVELOPPED ONLINE TECHNIQUE BASED ON LIMIT CYCLES IN 14-DIMENSIONS
%
% Last edition: 27.12.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
addpath("./Task9_tools");
rng('default');

% Setup python environment with anaconda and windows
setup_conda();

% Compute metrics
do_prediction_accuracy = false;
do_variance_computation = false;


% Info variables to plot

plot_trajectory = true;
plot_trajectory_init = true;
plot_x_n = true;
plot_constraint = true;
plot_error = false;
plot_RBD = false;
plot_limit_cycles = false;




%% 0) Variables and constraints

% Select one task
%Task = "Polar_DS";      % "Linear_DS", "Polar_DS"
Task = "Linear_DS";

% Feasibility constraint in x-domain (3D)
Task_region.upper_bound = [0.75,0.75,0.75];
Task_region.lower_bound = [0.25,0.25,0.25];

% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];


%% 1) Define RBD dynamic function

RBD_torque = @(robot, q_q_dot) inverseDynamics(robot, q_q_dot(1:7),q_q_dot(8:14), zeros(1,7));


%% 2) Import results from data folder

if strcmp(Task,"Linear_DS")
    data_q = load("data/Linear_DS_qs.mat");
    data_q = data_q.data_q;
    data_x = load("data/Linear_DS_xs.mat");
    data_x = data_x.data_x;
    
    % Number of GMM components
    nb_components = 7;
        
    
elseif strcmp(Task,"Polar_DS")
    data_q = load("data/Polar_DS_qs.mat");
    data_q = data_q.data_q;
    data_x = load("data/Polar_DS_xs.mat");
    data_x = data_x.data_x;
    
    % Number of GMM components
    nb_components = 8;
    
end



%% 3) Model the constrained region with GMM and rotation order

% Fit GMM on the joint space data (Q, QDOT)
RegularizationValue = 0.01;             % Regularization value to ensure postive Covariance
options = statset('MaxIter',10000);     % Increase number of max iterations
gm = fitgmdist(data_q, nb_components,'CovarianceType','full',...
        'RegularizationValue',RegularizationValue,...
        'Options',options);


 
%% 4) Setup feasibility constraints in (q,dot)

% Get joint constraints from urdf file
jointConst = constraintJointBounds(robot);
jointConst = jointConst.Bounds;

% Physical limits of the joint
feasibility.q_upper_bound = jointConst(:,2);
feasibility.q_lower_bound = jointConst(:,1);
feasibility.qdot_upper_bound = 1.5*ones(7,1);
feasibility.qdot_lower_bound = -1.5*ones(7,1);
feasibility.margin = 0.1;


%% 5) Define parameters and init Incremental GPR 

% Structure containing parameters of optimization
param = {};
params.traj_iter = 2;           % Index of the trajectory
params.region_thres = 15;       % Nb of "sigma" that is considered to be in region
params.robot_step = 0.05;       % Size of the step for computing the next point
params.convergence_dist = 0.05;  % Distance to be close enough to goal
params.delta_T = 0.01;          % update frequency of robot (min: 0.005)
params.alpha = 0.98;            % convergence rate for rho
params.beta = 0.5;              % Convergence rate for theta
params.sparseness = 10;         % Add point of trajectory all n iterations
params.P = 30;                  % Number of random points for select method number 2  


% Initialize 7 GP Regressors
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
regressors = cell(7,1);
for j=1:7
    regressors{j} = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);
end


%% 6) Initialization of the joint position and goals in each region

% Number of steps
steps = 5;

% Define staring postion of the "robot"
q_start = zeros(1,14);

% Initialize trajectory vector for plotting purpose
trajectory = zeros(1,14);
trajectory(1,:) = q_start;

% Initialize the goal of each region to be the center of the region
Q_next = gm.mu; %(7x14)

% Set center to 0 to minimize acceleration of each joint
% qc_center = 0;
% feasibility.qc_center = qc_center;



%% 8) First iteration

% First point
q_current = q_start;

opt_rho = cell(7,1);
opt_qc = cell(7,1);
for idx=1:7
    % Compute limit cylce passing through each "next" point in region 
    [opt_rho{idx}, opt_qc{idx}] = compute_limit_cycles(Q_next{idx}, feasibility,idx);
end

% Compute first trajectory of the limit cycle
[points_to_add, q_current, trajectory, params] = complete_trajectory(opt_rho, ...
    opt_qc, q_current, Q_next, gm, params, trajectory);

% Compute the torque corresponding to the points to add to the model
tau_to_add = get_torque(points_to_add(:,1:7),points_to_add(:,8:14));

if plot_trajectory_init
    figure 
    title("Trajectory 1st step")
    for idx = 1:7
        X = [data_q(:,idx),data_q(:,7+idx)];
        ax(idx) = subplot(4,2,idx);
        scatter(X(:,1),X(:,2),'*');
        hold on
        for k=1:nb_regions
           scatter(X(cluster_idx==labels(k),1),X(cluster_idx==labels(k),2),...
               'MarkerFaceAlpha',.4,'MarkerEdgeAlpha',.4);
        end
        xlabel("q"+string(idx))
        ylabel("q"+string(idx)+"dot")
        plot(trajectory(:,idx),trajectory(:,7+idx),'r'); 
    end
end


% Add point to model and compute updated GP incrementally
for j=1:size(points_to_add,1)
    rbd = RBD_torque(robot,points_to_add(j,:));
    for k=1:7
        regressors{k} = regressors{k}.update(points_to_add(j,:),...
            tau_to_add(j,k), rbd(k));
    end
end
for k=1:7
    regressors{k} = regressors{k}.fit();
end


% 
%     % Compute prediction error in task domain
%     if do_prediction_accuracy
%         prediction_error = zeros(steps,1);
%         [ypred, ~] = myGPR.predict(X, RBD(X));
%         prediction_error(1) = norm(ypred-y(X),2);
%     end
% 
%     % Compute the overall variance evolution in the regions
%     if do_variance_computation
%         variance_region = zeros(steps,1);
%         [~,yVar] = myGPR.predict(X,false);
%         variance_region(1) = sum(abs(yVar));
%     end




%% 9) Loop over main that balances exploration and exploitation

% Train incrementally by balancing exploration and task constraints
for i=1:steps
    
    % Select next point to go to 
    [Q_next,params] = select_next_in_region(gm, Q_next, regressors, feasibility, params);
    
    % Create limit cycles to go to the point
    for idx=1:7
        % Compute limit cylce passing through each "next" point in region 
        [opt_rho{idx}, opt_qc{idx}] = compute_limit_cycles(Q_next{idx}, feasibility,idx);
    end
    
        
    % Compute first trajectory of the limit cycle
    [points_to_add, q_current, trajectory, params] = complete_trajectory(opt_rho, ...
        opt_qc, q_current, Q_next, gm, params, trajectory);
    
   
    % Add point to model and compute updated GP incrementally
    for j=1:size(points_to_add,1)
        rbd = RBD_torque(robot,points_to_add(j,:));
        for k=1:7
            regressors{k} = regressors{k}.update(points_to_add(j,:),...
                tau_to_add(j,k), rbd(k));
        end
    end
    for k=1:7
        regressors{k} = regressors{k}.fit();
    end

%     % Compute error in task domain
%     if do_prediction_accuracy
%         [ypred, ~] = myGPR.predict(X, RBD(X));
%         prediction_error(i) = norm(ypred-y(X),2);
%     end
%     
%     % Compute the overall variance evolution in the regions
%     if do_variance_computation
%         [~,yVar] = myGPR.predict(X, false);
%         variance_region(i) = sum(abs(yVar));
%     end
    

    % Display during computation
    if mod(i,1)==0
        disp("Iteration: " + string(i) + "/" + string(steps));
    end
end



%% 10) Plot results

if plot_trajectory
    
    figure 
    title("Trajectory completed")
    for idx = 1:7
        X = [data_q(:,idx),data_q(:,7+idx)];
        ax(idx) = subplot(4,2,idx);
        scatter(X(:,1),X(:,2),'*');
        hold on
        for k=1:nb_regions
           scatter(X(cluster_idx==labels(k),1),X(cluster_idx==labels(k),2),...
               'MarkerFaceAlpha',.4,'MarkerEdgeAlpha',.4);
        end
        xlabel("q"+string(idx))
        ylabel("q"+string(idx)+"dot")
        plot(trajectory(:,idx),trajectory(:,7+idx),'r'); 
        plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
            [feasibility.qdot_upper_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
        plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
            [feasibility.qdot_lower_bound,feasibility.qdot_lower_bound],'r','LineWidth',sz);
        plot([feasibility.q_lower_bound,feasibility.q_lower_bound],...
            [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
        plot([feasibility.q_upper_bound,feasibility.q_upper_bound],...
            [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
        xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
        ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
    end       
end



% if do_prediction_accuracy
%     if plot_error
%         figure 
%         plot(1:length(prediction_error),prediction_error,'k');
%         hold on
%         %plot(linspace(1,length(prediction_error),2),ones(2,1)*prediction_error1,'r')
%         xlabel("Number of steps")
%         ylabel("Error in Torque")
%         title("Error of constrained model")
%     end
% 
%     if plot_RBD
%         y_truth =y(X);
%         rbd = RBD(X);
%         nb = 100;
% 
%         figure
%         plot(1:nb,ypred(1:nb),'k-o')
%         hold on
%         plot(1:nb,y_truth(1:nb),'b')
%         plot(1:nb, rbd(1:nb),'g')
%         legend("predicted2","truth", "RBD")
%     end
% end
% 
% 
% 
% if do_variance_computation
%     if plot_error
%         figure 
%         plot(1:length(variance_region),variance_region,'k');
%         hold on
%         xlabel("Number of steps")
%         ylabel("Variance in regions")
%         title("Variance of constrained model")
%     end
% end