%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO GENERATE REAL SET OF TRAJECTORIES BASED BASED ON A SPECIFIC
% TASK OF THE ROBOT. IT THEN EXPLORES THE TASK REGION USING THE PREVIOUSLY
% DEVELOPPED ONLINE TECHNIQUE BASED ON LIMIT CYCLES
%
% Last edition: 06.12.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
rng('default');


% Compute metrics
do_prediction_accuracy = false;
do_variance_computation = false;


% Info variables to plot

plot_trajectory = true;
plot_x_n = true;
plot_constraint = true;
plot_task_domain = true;
plot_error = false;
plot_RBD = false;
plot_limit_cycles = false;




%% 0) Variables and constraints

% Select one task
%Task = "Polar_DS";      % "Linear_DS", "Polar_DS"
Task = "Linear_DS";

% Feasibility constraint in x-domain (3D)
Task_region.upper_bound = [0.75,0.75,0.75];
Task_region.lower_bound = [0.25,0.25,0.25];



% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];





%% 1) Create points belonging to a specific task (x, xdot)

% Define a task for the robot x-space 

% Linear DS considers x to be 3D and be attracted by goal linearly
if strcmp(Task,"Linear_DS")
    goal = [0.5,0.5,0.5];
    alpha = -1; 
    Task_region.integration_time = 0.25;
    nb_trajectories = 100;
    nb_points_per_traj = 25;
    f = @(x) (alpha*eye(length(x))*(x-goal)')';
    
% Polar DS considers X is moving in a plane with constant limit cycle
elseif strcmp(Task,"Polar_DS")
    theta_dot = 1;
    x_center = [0.5,0.5,0.5];
    Task_region.integration_time = 0.1;
    nb_trajectories = 25;
    nb_points_per_traj = 100;
    f = @(x) theta_dot*([0,-1,0;1,0,0;0,0,0]*(x-x_center)')';
        
else
    error("Select one existing Task")
end
 

% Generate trajectories
X = zeros(nb_trajectories*nb_trajectories,3);

% Lower and upper-bound
LB = Task_region.lower_bound;
UB = Task_region.upper_bound;
rho_max = min([abs(LB(1)-x_center(1)), abs(UB(1)-x_center(1)), ...
                        abs(LB(2)-x_center(2)), abs(UB(2)-x_center(2))]);

for i=1:nb_trajectories
    
    % Initialize randomly point in task region
    if strcmp(Task,"Linear_DS")
       x_task = LB + (UB-LB).*rand(1,3);
       
    elseif strcmp(Task,"Polar_DS")
       rho = rho_max*rand(1,1);
       theta = 2*pi*rand(1,1);
       x_task = [x_center(1)+rho*cos(theta),x_center(2)+rho*sin(theta),x_center(3)];
    end
    
    % Compute n steps from the starting position following task def
    for j=1:nb_points_per_traj
        X(j+nb_points_per_traj*(i-1),:) = x_task;
        x_task_dot = f(x_task);
        x_task = x_task + x_task_dot * Task_region.integration_time;
         
    end
end

if plot_task_domain
    figure
    hold on
    xlim([Task_region.lower_bound(1),Task_region.upper_bound(1)])
    ylim([Task_region.lower_bound(2),Task_region.upper_bound(2)])
    zlim([Task_region.lower_bound(3),Task_region.upper_bound(3)])
    for k=1:nb_trajectories
        i_s = 1+(k-1)*nb_points_per_traj;
        i_end = i_s + nb_points_per_traj-1;
        plot3(X(i_s:i_end,1),X(i_s:i_end,2),X(i_s:i_end,3))
    end
end


%% 2) Compute inverse kinematics from (x,xdot) to obtain (q,qdot)

gik = generalizedInverseKinematics('RigidBodyTree', robot, ...
    'ConstraintInputs', {'position','joint'});


q = zeros(nb_trajectories*nb_trajectories,7);
q_dot = zeros(nb_trajectories*nb_trajectories,7);

% Joint limit bounds
jointLimBounds = constraintJointBounds(gik.RigidBodyTree);
jointLimBounds.Weights = ones(1,size(gik.RigidBodyTree.homeConfiguration,2))*10;

% Target constraint
positionTarget = constraintPositionTarget('iiwa_link_ee');
positionTarget.PositionTolerance = 1e-6;
positionTarget.Weights = 1;

for i=1:nb_trajectories
    
    % Compute n steps from the starting position following task def
    for j=1:nb_points_per_traj
        
        disp("Traj: " + string(i)+ "   Point: "+string(j))
        
        % Position constraint
        desiredEEPosition = X(j+nb_points_per_traj*(i-1),:)';       % Position is relative to base.
        positionTarget.TargetPosition = desiredEEPosition; 

        % Solves Inverse Kinematics
        if j==1
            iniGuess = homeConfiguration(robot);
        else 
            iniGuess = q(j+nb_points_per_traj*(i-1)-1,:);
        end
        
        % Compute q
        [opt_q, solutionInfo] = gik(iniGuess,positionTarget,jointLimBounds);
        q(j+nb_points_per_traj*(i-1),:) = opt_q;
        
        % Compute qdot
        jacobian = geometricJacobian(robot,opt_q,'iiwa_link_ee');
        xdot = f(desiredEEPosition');
        xdot = [xdot';0;0;0];
        qdot = sdpvar(1,size(gik.RigidBodyTree.homeConfiguration,2));
        opt_settings = sdpsettings('solver', 'gurobi', 'verbose', 0);
        optimize([],sum((xdot-jacobian*qdot').^2), opt_settings);
        opt_qdot = value(qdot);
        q_dot(j+nb_points_per_traj*(i-1),:) = opt_qdot;
         
    end
end


% PLOT OF THE ROBOT CONFIGURATION
% figure
% subplot(1,2,1)
% show(robot,homeConfiguration(robot));
% title('Home Configuration')
% view([0 -1 0]);
% subplot(1,2,2)
% show(robot,q);
% title('GIK Solution')
% view([0 -1 0]);




%% PLOT OF Q QDOT

figure
title("Task space analysis")
for idx =1:6
    ax(idx) = subplot(3,2,idx);
    scatter(q(:,idx),q_dot(:,idx),'*')
    xlabel("q"+string(idx))
    ylabel("q"+string(idx)+"dot")
end
linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'x')
linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'y')




%% 3) Compute corresponding torque using the neural network

setup_conda();

% Save dataset into the right directory
generate_test_data(q, q_dot)

% Execute python script
!python learning/ANN_coupled/scripts/testModels.py

% Read the results of the NN
tau = read_test_torque();




%% 4) Model the constrained region with GMM and rotation order

% Number of Gaussians for GMM
nb_gaussians = 3;

% Fit gmm with nb_gaussians components on the task regions
gm = fitgmdist(X,nb_gaussians);

% Determine rotation order of the regions
angle_from_center = atan2(gm.mu(:,2),gm.mu(:,1));
for i=1:nb_gaussians
    if angle_from_center(i) < 0
        angle_from_center(i) = angle_from_center(i) + 2*pi;
    end
end
[~,rotation_order_idx] = sort(angle_from_center,'descend');

% determine principal axis
e1 = zeros(size(gm.mu,1),size(gm.mu,2));
for i=1:nb_gaussians
    [eigvector,eigvl]=eig(gm.Sigma(:,:,i));
    eigvalue = diag(eigvl);
    [~,id] = sort(eigvalue,'descend');
    sorted_eig = eigvector(:,id);
    e1(i,:) = sorted_eig(:,1);
end



%% 5) Setup feasibility constraints in (q,dot)

% Get joint constraints from urdf file
jointConst = constraintJointBounds(robot);
jointConst = jointConst.Bounds;

% Physical limits of the joint
feasibility.q_upper_bound = jointConst(:,2);
feasibility.q_lower_bound = jointConst(:,1);
feasibility.qdot_upper_bound = 6;
feasibility.qdot_lower_bound = -6;
feasibility.margin = 0.1;
feasibility.e1 = e1;



%% 6) Define parameters and init Incremental GPR 

% Structure containing parameters of optimization
param = {};
params.I_var = 2;               % Importance of the variance
params.traj_iter = 2;           % Index of the trajectory
params.region_thres = 2.5;      % Nb of "sigma" that is considered to be in region
params.robot_step = 0.05;        % Size of the step for computing the next point
params.convergence_dist = 0.1;  % Distance to be close enough to goal
params.delta_T = 0.01;          % update frequency of robot (min: 0.005)
params.alpha = 0.95;             % convergence rate for rho
params.beta = 0.5;              % Convergence rate for theta
params.sparseness = 10;         % Add point of trajectory all n iterations
params.P = 20;                  % Number of random points for select method number 2  
params.M = 3;                   % Number of step from random points for select method number 3&4
params.N = 20;                  % Number of random directions for select method 3

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);



%% 7) Initialization of the joint position and goals in each region

% Number of steps
steps = 5;

% Define staring postion of the "robot"
x_start = [4,0];

% Initialize trajectory vector for plotting purpose
trajectory = zeros(1,2);
trajectory(1,:) = x_start;

% Initialize the goal of each region to be the center of the region
X_next = gm.mu;     % (nb_gaussians x N)

%qc_center = mean(gm.mu(:,1));
qc_center = 0;
feasibility.qc_center = qc_center;



%% 8) First iteration

% First point
x_current = x_start;

% Compute limit cylce passing through each "next" point in region
[opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);



if plot_limit_cycles
    figure
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    th = 0:pi/50:2*pi;
    for i = 1:3
        xunit = opt_rho(i) * cos(th) + opt_qc(i);
        yunit = opt_rho(i) * sin(th);
        h = plot(xunit, yunit,'m');
    end
end



% Compute first trajectory of the limit cycle
[points_to_add, x_current, trajectory, params] = complete_trajectory2(opt_rho, ...
    opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);

% Add point to model and compute updated GP incrementally
for j=1:size(points_to_add,1)
    myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
end
myGPR = myGPR.fit();



% Compute prediction error in task domain
if do_prediction_accuracy
    prediction_error = zeros(steps,1);
    [ypred, ~] = myGPR.predict(X, RBD(X));
    prediction_error(1) = norm(ypred-y(X),2);
end

% Compute the overall variance evolution in the regions
if do_variance_computation
    variance_region = zeros(steps,1);
    [~,yVar] = myGPR.predict(X,false);
    variance_region(1) = sum(abs(yVar));
end



%% 9) Loop over main that balances exploration and exploitation

x_n_visualize = zeros(3*steps,2);

% Train incrementally by balancing exploration and task constraints
for i=1:steps
    
    % Select next point to go to 
    [X_next,params] = select_next_in_region3(gm, X_next, myGPR, feasibility, params);
    for j=1:3
        x_n_visualize(3*(i-1)+j,:) = X_next(j,:);
    end
    
    % Create limit cycles to go to the point
    [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);
    
        
    % move along limit cycles until reaching destination (2pi rotation)
    [points_to_add, x_current, trajectory, params] = complete_trajectory2(opt_rho, ...
        opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
    
    
    % Increment importance of exploration
    params.I_var = 0.25+3*i/(4*steps);
     

    % Add point to model and compute updated GP incrementally
    for j=1:size(points_to_add,1)
        myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
    end
    myGPR = myGPR.fit();

    % Compute error in task domain
    if do_prediction_accuracy
        [ypred, ~] = myGPR.predict(X, RBD(X));
        prediction_error(i) = norm(ypred-y(X),2);
    end
    
    % Compute the overall variance evolution in the regions
    if do_variance_computation
        [~,yVar] = myGPR.predict(X, false);
        variance_region(i) = sum(abs(yVar));
    end
    

    % Display during computation
    if mod(i,1)==0
        disp("Iteration: " + string(i) + "/" + string(steps));
    end
end



%% 10) Plot results


if plot_trajectory
    sz = 2;
    if not(plot_limit_cycles)
        figure 
    end
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    plot(trajectory(:,1),trajectory(:,2),'k');
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_upper_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_lower_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_lower_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_upper_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    xlabel("q1")
    ylabel("q1dot")
    xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
    ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
    title("Task Constraints - Positions/Velocities")
        
end



if plot_x_n
   figure 
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    scatter(x_n_visualize(:,1),x_n_visualize(:,2),'r')
    xlabel("q1")
    ylabel("q1dot")
    xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
    ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
end


if do_prediction_accuracy
    if plot_error
        figure 
        plot(1:length(prediction_error),prediction_error,'k');
        hold on
        %plot(linspace(1,length(prediction_error),2),ones(2,1)*prediction_error1,'r')
        xlabel("Number of steps")
        ylabel("Error in Torque")
        title("Error of constrained model")
    end

    if plot_RBD
        y_truth =y(X);
        rbd = RBD(X);
        nb = 100;

        figure
        plot(1:nb,ypred(1:nb),'k-o')
        hold on
        plot(1:nb,y_truth(1:nb),'b')
        plot(1:nb, rbd(1:nb),'g')
        legend("predicted2","truth", "RBD")
    end
end



if do_variance_computation
    if plot_error
        figure 
        plot(1:length(variance_region),variance_region,'k');
        hold on
        xlabel("Number of steps")
        ylabel("Variance in regions")
        title("Variance of constrained model")
    end
end