%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO GENERATE REAL SET OF TRAJECTORIES BASED BASED ON A SPECIFIC
% TASK OF THE ROBOT.
%
% Last edition: 12.12.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

%rng('default');

plot_task_domain = true;

%% 0) Variables and constraints

% Select one task
%Task = "Polar_DS";      % "Linear_DS", "Polar_DS"
Task = "Linear_DS";

data_name = "data/"+ Task + "_qs.mat";
data_name2 = "data/"+ Task + "_xs.mat";

% Feasibility constraint in x-domain (3D)
Task_region.upper_bound = [0.75,0.75,0.75];
Task_region.lower_bound = [0.25,0.25,0.25];

% import iiwa14 robot tree from urdf file
robot = importrobot('../data/iiwa14.urdf');
robot.DataFormat = "row";
robot.Gravity = [0,0,-9.81];





%% Create points belonging to a specific task (x, xdot)

% Define a task for the robot x-space 

% Linear DS considers x to be 3D and be attracted by goal linearly
if strcmp(Task,"Linear_DS")
    goal = [0.5,0.5,0.5];
    alpha = -1; 
    Task_region.integration_time = 0.25;
    nb_trajectories = 100;
    nb_points_per_traj = 25;
    f = @(x) (alpha*eye(length(x))*(x-goal)')';
    
% Polar DS considers X is moving in a plane with constant limit cycle
elseif strcmp(Task,"Polar_DS")
    theta_dot = 1;
    x_center = [0.5,0.5,0.5];
    Task_region.integration_time = 0.1;
    nb_trajectories = 25;
    nb_points_per_traj = 100;
    f = @(x) theta_dot*([0,-1,0;1,0,0;0,0,0]*(x-x_center)')';
        
else
    error("Select one existing Task")
end
 

% Generate trajectories
X = zeros(nb_trajectories*nb_trajectories,3);

% Lower and upper-bound
LB = Task_region.lower_bound;
UB = Task_region.upper_bound;
if strcmp(Task,"Polar_DS")
rho_max = min([abs(LB(1)-x_center(1)), abs(UB(1)-x_center(1)), ...
                        abs(LB(2)-x_center(2)), abs(UB(2)-x_center(2))]);
end



% Inverse kinematics solver
gik = generalizedInverseKinematics('RigidBodyTree', robot, ...
    'ConstraintInputs', {'position','joint','orientation'});


q = zeros(nb_trajectories*nb_trajectories,7);
q_dot = zeros(nb_trajectories*nb_trajectories,7);

% Joint limit bounds
jointLimBounds = constraintJointBounds(gik.RigidBodyTree);
jointLimBounds.Weights = ones(1,size(gik.RigidBodyTree.homeConfiguration,2))*10;

fixOrientation = constraintOrientationTarget('iiwa_link_ee');
fixOrientation.OrientationTolerance = deg2rad(1);

% Target constraint
positionTarget = constraintPositionTarget('iiwa_link_ee');
positionTarget.PositionTolerance = 1e-6;
positionTarget.Weights = 1;



for i=1:nb_trajectories
    for j=1:nb_points_per_traj
        
        % 0) find x_start randomly in the region
        if j==1
            % Initialize randomly point in task region
            if strcmp(Task,"Linear_DS")
               x_task = LB + (UB-LB).*rand(1,3);

            elseif strcmp(Task,"Polar_DS")
               rho = rho_max*rand(1,1);
               theta = 2*pi*rand(1,1);
               x_task = [x_center(1)+rho*cos(theta),x_center(2)+rho*sin(theta),x_center(3)];
            end
        else
        
        % Store x_task
        X(j+nb_points_per_traj*(i-1),:) = x_task;
        
        % 1) Compute xdot using the dynamical system DS
        x_task_dot = f(x_task);
        
        % 2) Compute qdot by solving the inverse kinematics
        jacobian = geometricJacobian(robot,opt_q,'iiwa_link_ee');
        xdot = f(desiredEEPosition');
        xdot = [xdot';0;0;0];
        qdot = sdpvar(1,size(gik.RigidBodyTree.homeConfiguration,2));
        opt_settings = sdpsettings('solver', 'gurobi', 'verbose', 0);
        optimize([],sum((xdot-jacobian*qdot').^2), opt_settings);
        opt_qdot = value(qdot);
        
        % 3) Compute q by integrating q
        
        
        % 4) Compute x by forward kinematics
        
        
        
    end
         
    
end






%% Save data

data_q = [q,q_dot];
data_x = X;
save(data_name,'data_q');
save(data_name2,'data_x');


%% PLOT OF Q QDOT


if plot_task_domain
    figure
    hold on
    xlim([Task_region.lower_bound(1),Task_region.upper_bound(1)])
    ylim([Task_region.lower_bound(2),Task_region.upper_bound(2)])
    zlim([Task_region.lower_bound(3),Task_region.upper_bound(3)])
    for k=1:nb_trajectories
        i_s = 1+(k-1)*nb_points_per_traj;
        i_end = i_s + nb_points_per_traj-1;
        plot3(X(i_s:i_end,1),X(i_s:i_end,2),X(i_s:i_end,3))
    end
end


figure
title("Task space analysis")
for idx =1:6
    ax(idx) = subplot(3,2,idx);
    scatter(q(:,idx),q_dot(:,idx),'*')
    xlabel("q"+string(idx))
    ylabel("q"+string(idx)+"dot")
end

linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'x')
linkaxes([ax(1),ax(2),ax(3),ax(4),ax(5),ax(6)],'y')


