function [points_to_add, x_current, trajectory, params] = complete_trajectory(rho, ...
    qc, x_current, x_next, gm, params, trajectory, test)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION "MOVES" ALONG THE LIMIT CYCLE WHILE COLLECTING DATA OF THE
% REGIONS OF INTEREST UNTIL IT REACHES ZERO VELOCITY AGAIN.
%
% Input: - rho            : (double) Radius of limit cycle
%        - qc             : (double) Center of limit cycle 
%        - x_current      : (1xP) Last considered datapoint of dimension P
%        - x_next         : (1xP) Goal datapoint of dimension P
%        - GPR            : (object) GP regressor
%        - params         : (struct) Parameters
%        - trajectory     : (kxP) All points that have been visited
%        - test           : (bool) if it is the test file (no gmm)
%
%
% Ouput: - points_to_add  : (HxP) Array containing all points to add
%        - x_current      : (1xP) Last considered datapoint of dimension P
%        - trajectory     : (kxP) All points that have been visited
%        - params         : (struct) Parameters
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Function that computes the Mahalanobis distance
MahaDist = @(x,idx) sqrt(diag((x-gm.mu(idx,:))*(gm.Sigma(:,:,idx)\(x-gm.mu(idx,:))')));

has_converged = false;
points_to_add = [];

% Actual cycle
x_center = x_current-[qc,0];
rho_j = norm(x_center,2);
theta_j = atan2(x_center(2),x_center(1));


while (has_converged == false)

    % Convergence rate
    rho_dot_j = -1*params.alpha * (rho_j-rho);
    theta_dot_j = -1*params.beta * exp(-params.alpha^2*(rho_j-rho)^2);

    % Integreation
    rho_j = rho_j + params.delta_T*rho_dot_j;
    theta_j = theta_j + params.delta_T * theta_dot_j;

    % New point 
    x_current(1) = rho_j*cos(theta_j)+qc;
    x_current(2) = rho_j*sin(theta_j);
    
    trajectory(params.traj_iter,:) = x_current;
    params.traj_iter = params.traj_iter + 1;
    
    % Add point to model if in region
    if not(test)
        
        % find smallest Mahalanobis distance to all clusters
        min_dist = 1e10;
        for idx=1:size(gm.mu,1)
            M_distance = MahaDist(x_current,idx);
            if M_distance < min_dist
                min_dist = M_distance;
            end
        end
        
        % If points in one region of interest, add it to the model
        if min_dist < params.region_thres
            points_to_add = [points_to_add; x_current];
        end
    end
   
    % Check if arrived
    if norm(x_current-x_next,2) <= params.convergence_dist
        has_converged = true;
    end
end

end