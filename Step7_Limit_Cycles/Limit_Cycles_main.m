%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO COMPUTE THE ANALYSE DIFFERENT METHODE OF EXPLORATION IN A 
% CONSTRAINED ENVIRONMENT USING NONPARAMETRIC INCREMENTAL GAUSSIAN PROCESS.
%
% Last edition: 17.11.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
rng('default');

nb_gaussians = 3;

plot_constraint = false;
plot_trajectory = true;
plot_error = false;
plot_RBD = false;
plot_limit_cycles = false;



%% 1) Create 2d constrained environment (q,qdot)

% Sample datapoints as constrained environement

sc = 0.1;
% Constraint 1
m1 = sc*[-10;25];	  %Mean
sigma1 = sc^2*10*eye(2);	  %Variance
d1 = 100;             %Length
z1 = mvnrnd(m1,sigma1,d1);


% Constraint 2
m2 = sc*[25;15];     %Mean
sigma2 = sc^2*diag([30;30]);	  %Variance
d2 = 250;             %Length
z2 = mvnrnd(m2,sigma2,d2);

% Constraint 3
m3 = sc*[-25;-5];	%Mean
sigma3 = sc^2*diag([6;30]);	    %Variance
d3 = 300;               %Length
z3 = mvnrnd(m3,sigma3,d3);

if plot_constraint
    figure 
    scatter(z1(:,1),z1(:,2))
    hold on
    scatter(z2(:,1),z2(:,2))
    scatter(z3(:,1),z3(:,2))
    xlabel("q")
    ylabel("qdot")
    title("Task Constraints")
    
end
 

% Use two sines as prior and ground truth of the torque   
RBD = @(A) 1.2*sin(sum(A,2)/50*pi);
y = @(A) 2.3*sin(sum(A,2)/50*pi);


%% 2) Model the constrained region with GMM and rotation order

% Group task regions into one dataset
X = [z1;z2;z3];

% Fit gmm with nb_gaussians components on the task regions
gm = fitgmdist(X,nb_gaussians);

% Determine rotation order of the regions
angle_from_center = atan2(gm.mu(:,2),gm.mu(:,1));
for i=1:nb_gaussians
    if angle_from_center(i) < 0
        angle_from_center(i) = angle_from_center(i) + 2*pi;
    end
end
[~,rotation_order_idx] = sort(angle_from_center,'descend');




%% 3) Setup feasibility constraints

% Physical limits of the joint
feasibility = {};
feasibility.q_upper_bound = 6;
feasibility.q_lower_bound = -6;
feasibility.qdot_upper_bound = 4;
feasibility.qdot_lower_bound = -4;
feasibility.margin = 0.1;


%% 3) Define parameters and init Incremental GPR 

% Structure containing parameters of optimization
param = {};
params.I_clust = [d1;d2;d3];     % Importance of each cluset
params.I_var = 0.25;             % Importance of the variance
params.traj_iter = 2;            % Index of the trajectory
params.region_thres = 2;         % Nb of "sigma" that is considered to be in region
params.boundary_thres = 3;       % Nb of "sigma" to be outside a region but still close enough
params.robot_step = 0.4;         % Size of the step for computing the next point
params.convergence_dist = 0.1;   % Distance to be close enough to goal
params.delta_T = 0.01;            % update frequency of robot (min: 0.005)
params.alpha = 0.2;              % convergence rate for rho
params.beta = 0.3;               % Convergence rate for theta

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);



%% 4) Initialization of the joint position and goals in each region

% Number of steps
steps = 1;

% Define staring postion of the "robot"
x_start = [2,0];

% Initialize trajectory vector for plotting purpose
trajectory = zeros(1,2);
trajectory(1,:) = x_start;

% Initialize the goal of each region to be the center of the region
X_next = gm.mu;     % (nb_gaussians x N) 


%% 5) First iteration

% First point
x_current = x_start;

% Compute limit cylce passing through each "next" point in region
[opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);


% Visualize first iteration Limit Cycles
% th = 0:pi/50:2*pi;
% xunit1 = opt_rho(1) * cos(th) + opt_qc(1);
% yunit1 = opt_rho(1) * sin(th);
% xunit2 = opt_rho(2) * cos(th) + opt_qc(2);
% yunit2 = opt_rho(2) * sin(th);
% xunit3 = opt_rho(3) * cos(th) + opt_qc(3);
% yunit3 = opt_rho(3) * sin(th);
% figure
% plot(xunit1, yunit1,'m');
% hold on
% plot(xunit2, yunit2,'m');
% plot(xunit3, yunit3,'m');


% Compute first trajectory of the limit cycle
[points_to_add, x_current, trajectory, params] = complete_trajectory(opt_rho, ...
    opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);

% Add point to model and compute updated GP incrementally
for j=1:size(points_to_add,1)
    myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
end
myGPR = myGPR.fit();

% Compute error in task domain
prediction_error = zeros(steps,1);
[ypred, ~] = myGPR.predict(X, RBD(X));
prediction_error(1) = norm(ypred-y(X),2);



%% 6) Loop over main that balances exploration and exploitation

% Train incrementally by balancing exploration and task constraints
for i=1:steps
    
    % Select next point to go to 
    %%%%%%%%%%%%%%%%% (TODO!) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % Create limit cycles to go to the point
    [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);
    
        
    % move along limit cycles until reaching destination (2pi rotation)
    [points_to_add, x_current, trajectory, params] = complete_trajectory(opt_rho, ...
        opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
    
    
    % Increment importance of exploration
    params.I_var = 0.25+3*i/(4*steps);
     

    % Add point to model and compute updated GP incrementally
    for j=1:size(points_to_add,1)
        myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
    end
    myGPR = myGPR.fit();

    % Compute error in task domain
    [ypred, ~] = myGPR.predict(X, RBD(X));
    prediction_error(i) = norm(ypred-y(X),2);
    
    

    disp("step: " + string(i))
%     % Display during computation
%     if mod(i,5)==0
%         disp("Iteration: " + string(i) + "/" + string(steps));
%     end
end



%% 7) Plot results

if plot_trajectory
    sz = 2;
    if not(plot_limit_cycles)
        figure 
    end
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    plot(trajectory(:,1),trajectory(:,2),'k');
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_upper_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_lower_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_lower_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_upper_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    xlabel("q1")
    ylabel("q1dot")
    xlim([feasibility.q_lower_bound-1,feasibility.q_upper_bound+1])
    ylim([feasibility.qdot_lower_bound-1,feasibility.qdot_upper_bound+1])
    title("Task Constraints - Positions/Velocities")
        
end

if plot_error
    figure 
    plot(1:length(prediction_error),prediction_error,'k');
    hold on
    %plot(linspace(1,length(prediction_error),2),ones(2,1)*prediction_error1,'r')
    xlabel("Number of steps")
    ylabel("Error in Torque")
    title("Error of constrained model")
end
    
if plot_RBD
    y_truth =y(X);
    rbd = RBD(X);
    nb = 100;

    figure
    plot(1:nb,ypred(1:nb),'k-o')
    hold on
    plot(1:nb,y_truth(1:nb),'b')
    plot(1:nb, rbd(1:nb),'g')
    legend("predicted2","truth", "RBD")
end