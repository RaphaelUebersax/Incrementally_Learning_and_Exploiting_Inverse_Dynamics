function [X_next,params] = select_next_in_region3(gm, X_prev, GPR, feasibility, params)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION RETURNS THE NEXT DATAPOINT TO GO IN EACH REGION USING THE
% THE POINT WITH THE MAXIMUM VARIANCE AFTER HAVING PERFORMED M-STEP OF
% GRADIENT OF THE VARIANCE.
%
% Input: - gm             : (object) GMM model fit on task constraints
%        - X_prev         : (nb_gaussians x P) Previous goal datapoints of dimension P
%        - GPR            : (object) Gaussian Process Regressor
%        - feasibility    : (struct) Feasibility constraints of robot
%        - params         : (struct) Parameters
%
%
% Ouput: - X_next         : (nb_gaussians x P) Goal datapoints of dimension P
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nb_gaussians = size(X_prev,1);
X_next = zeros(nb_gaussians,size(X_prev,2));

% Function that computes the Mahalanobis distance
MahaDist = @(x,idx) sqrt(diag((x-gm.mu(idx,:))*(gm.Sigma(:,:,idx)\(x-gm.mu(idx,:))')));


for i=1:nb_gaussians
    
    % Compute N directions from the current point to start computation
    Y_i = zeros(params.N, size(X_prev,2));
    Y_i(1,:) = X_prev(i,:) + GPR.gradient_var(X_prev(i,:))*params.robot_step;
    for n=2:params.N
        dir = -1+2*rand(1,size(X_prev,2));
        dir = dir/norm(dir);
        Y_i(n,:) = X_prev(i,:) + dir;
    end
        
    % Compute M steps towards max variance from random point
    j = 1;
    nb_points = 0;
    Y_n = zeros(1,size(X_prev,2));
    for n=1:params.N
        for m=2:params.M
            % Step towards maximum variance
            grad_var_n = GPR.gradient_var(Y_i(n,:));
            Y_i(n,:) = Y_i(n,:) + grad_var_n*params.robot_step;
        end

        % Check if point is in region
        Y_n_dist = MahaDist(Y_i(n,:),i);
        if Y_n_dist <= params.region_thres
            nb_points = nb_points+1;
            Y_n(nb_points,:) = Y_i(n,:);
        end
    end
      
    if Y_n == zeros(1,size(X_prev,2))
        grad_var_c = GPR.gradient_var(gm.mu(i,:));
        if norm(grad_var_c,2) ~= 0
            deltaVar_c = grad_var_c/norm(grad_var_c,2)*params.robot_step;
        else
            deltaVar_c = grad_var_c;
        end
        X_next(i,:) = gm.mu(i,:) + deltaVar_c;
    else
        % Compute variance of all the points
        [~, Var_n] = GPR.predict(Y_n, false);
        [~, idx] = sort(Var_n,'descend');

        % Assign next point
        position = 1;
        X_next(i,:) = Y_n(idx(position),:);

        % Make sure point is feasible
        while not(is_feasible_point(X_next(i,:),feasibility))
            position = position + 1;
            X_next(i,:) = Y_i(idx(position),:); 
        end
    end
end
    


end