function [points_to_add, x_current, trajectory, params] = complete_trajectory(rho, ...
    qc, x_current, X_next, gm, params, trajectory, rotation_order_idx)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION "MOVES" ALONG THE LIMIT CYCLE WHILE COLLECTING DATA OF THE
% REGIONS OF INTEREST UNTIL IT REACHES ZERO VELOCITY AGAIN.
%
% Input: - rho                 : (nb_gaussians x 1) Radius of limit cycles
%        - qc                  : (nb_gaussians x 1) Center of limit cycles 
%        - x_current           : (1 x P) Last considered datapoint of dimension P
%        - X_next              : (nb_gaussians x P) Goal datapoint of dimension P
%        - params              : (struct) Parameters
%        - trajectory          : (k x P) All points that have been visited
%        - rotation_order_idx  : (1 x nb_gaussians) Rotation order 
%
%
% Ouput: - points_to_add       : (H x P) Array containing all points to add
%        - x_current           : (1 x P) Last considered datapoint of dimension P
%        - trajectory          : (k x P) All points that have been visited
%        - params              : (struct) Parameters
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Function that computes the Mahalanobis distance
MahaDist = @(x,idx) sqrt(diag((x-gm.mu(idx,:))*(gm.Sigma(:,:,idx)\(x-gm.mu(idx,:))')));

% Initialization of loop parameters
has_converged = false;
points_to_add = [];
region_nb = 1;


while (has_converged == false)

    % Update region_nb if region is passed
    x_center_current = x_current-[qc(rotation_order_idx(region_nb)),0];
    angle_current = atan2(x_center_current(2),x_center_current(1));
    x_center_next = X_next(rotation_order_idx(region_nb),:)-[qc(rotation_order_idx(region_nb)),0];
    angle_next = atan2(x_center_next(2),x_center_next(1));
    if angle_current <= 0
        angle_current = angle_current + 2*pi;
    end
    if angle_next <= 0
        angle_next = angle_next + 2*pi;
    end
    
    if (angle_current < angle_next) && (region_nb ~= length(rotation_order_idx))
       region_nb = region_nb + 1 ;
    end
    
    % Actual cycle of x_current at the begining
    x_center = x_current-[qc(rotation_order_idx(region_nb)),0];
    rho_j = norm(x_center,2);
    theta_j = atan2(x_center(2),x_center(1));
    
    
    % Computation of desired radius rho_d and center qc_d
    rho_d = rho(rotation_order_idx(region_nb));
    qc_d = qc(rotation_order_idx(region_nb));
    
    % Convergence rate
    rho_dot_j = -1*params.alpha * (rho_j-rho_d);
    theta_dot_j = -1*params.beta * exp(-params.alpha^2*(rho_j-rho_d)^2);

    % Integreation
    rho_j = rho_j + params.delta_T*rho_dot_j;
    theta_j = theta_j + params.delta_T * theta_dot_j;

    % New point 
    x_prev = x_current;
    x_current(1) = rho_j*cos(theta_j)+qc_d;
    x_current(2) = rho_j*sin(theta_j);
    
    trajectory(params.traj_iter,:) = x_current;
    params.traj_iter = params.traj_iter + 1;
    
    % Add point to model if in region
    %   find smallest Mahalanobis distance to all clusters
    min_dist = 1e10;
    for idx=1:size(gm.mu,1)
        M_distance = MahaDist(x_current,idx);
        if M_distance < min_dist
            min_dist = M_distance;
        end
    end

    % If points in one region of interest, add it to the model
    if min_dist < params.region_thres
        points_to_add = [points_to_add; x_current];
    end
   
    
    % Check if arrived (qdot>=0 and qdot < thres)
    if (x_current(2) <= params.convergence_dist) && (x_current(2) >= 0) && ...
            (x_prev(2) > x_current(2))
        
        % Stop the trajectory
        has_converged = true;
        
        % Set next point to be on horizontal axis (0-velocity)
        x_current = [x_current(1),0];

        % Add this point to the trajectoy
        trajectory(params.traj_iter,:) = x_current;
        params.traj_iter = params.traj_iter + 1;
    end
    
end

end