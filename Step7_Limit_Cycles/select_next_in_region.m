function [X_next,params] = select_next_in_region(gm, X_prev, GPR, feasibility, params)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION RETURNS THE NEXT DATAPOINT TO GO IN EACH REGION.
%
% Input: - gm             : (object) GMM model fit on task constraints
%        - X_prev         : (nb_gaussians x P) Previous goal datapoints of dimension P
%        - GPR            : (object) Gaussian Process Regressor
%        - feasibility    : (struct) Feasibility constraints of robot
%        - params         : (struct) Parameters
%
%
% Ouput: - X_next         : (nb_gaussians x P) Goal datapoints of dimension P
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

nb_gaussians = size(X_prev,1);
X_next = zeros(nb_gaussians,size(X_prev,2));

% Function that computes the Mahalanobis distance
MahaDist = @(x,idx) sqrt(diag((x-gm.mu(idx,:))*(gm.Sigma(:,:,idx)\(x-gm.mu(idx,:))')));


% Select maximum variance direction in each region
for i=1:nb_gaussians
        % Compute the step towards the center of the GM
    diffX = gm.mu(i,:)-X_prev(i,:);
    if norm(diffX,2) ~= 0
        deltaW = diffX/norm(diffX,2)*params.robot_step;
    else
        deltaW = diffX;
    end
    
    % Step towards maximum variance
    grad_var = GPR.gradient_var(X_prev(i,:));
    if norm(grad_var,2) ~= 0
        deltaVar = grad_var*params.robot_step;
        %deltaVar = grad_var/norm(grad_var,2)*params.robot_step;
    else
        deltaVar = diffW;
    end


    % Compute probability associated to datapoint
    M_distance = MahaDist(X_prev(i,:),i);

    if M_distance < params.region_thres
        % Case: In region --> Mainly exploration
        deltaX = deltaVar;
        X_next(i,:) = X_prev(i,:) + deltaX;  %Update datapoint

    else
        % Case: Far from region --> Go to center of region with one step!
        % Step towards maximum variance
        grad_var_c = GPR.gradient_var(gm.mu(i,:));
        if norm(grad_var,2) ~= 0
            deltaVar_c = grad_var_c/norm(grad_var_c,2)*params.robot_step;
        else
            deltaVar_c = grad_var_c;
        end
        X_next(i,:) = gm.mu(i,:) + deltaVar_c;
    end
    
end


% Ensure that x is feasible (reduce step if not)
t = 0.9;
while not(is_feasible_point(X_next(i,:),feasibility))
    deltaX = t*deltaX;
    X_next(i,:) = X_prev(i,:) + deltaX;  
end

end