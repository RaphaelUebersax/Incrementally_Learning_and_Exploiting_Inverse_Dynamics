%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% MATLAB SCIPT TO COMPARE THE TWO DIFFERENT INTER CLUSTER EXPLORATION 
% APPROACHES IN TERMS OF ACCURACY OF THE PREDICTION AS WELL AS DECRESING
% GPR VARIANCES ASSOCIATED TO IT.
%
% Last edition: 29.11.2021
% Author: Raphael Uebersax
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
addpath("../Step7_Limit_Cycles");
addpath("../Step6_Task_Constraints");
rng('default');

% Experiment number to reproduce results of the report
experiment = 1;

% Number of Gaussians for GMM
nb_gaussians = 3;

% Select the complete trajectory method 
complete_traj = 2;

% Compute metrics
do_prediction_accuracy = true;
do_variance_computation = true;


% Info variables to plot
plot_constraint = true;
plot_trajectory = false;
plot_x_n = false;
plot_error = true;
plot_RBD = false;
plot_limit_cycles = false;



%% 1) Create 2d constrained environment (q,qdot)

% Sample datapoints as constrained environement
if experiment == 1

    sc = 0.1;
    % Constraint 1
    m1 = sc*[-40;10];	              %Mean
    sigma1 = sc^2*[15,-20;-20,60];	  %Variance
    d1 = 50;                         %Length
    z1 = mvnrnd(m1,sigma1,d1);


    % Constraint 2
    m2 = sc*[-20;35];                  %Mean
    sigma2 = sc^2*diag([6;30]);	  %Variance
    d2 = 250;                         %Length
    z2 = mvnrnd(m2,sigma2,d2);

    % Constraint 3
    m3 = sc*[-5;-30];	            %Mean
    sigma3 = sc^2*[40,0;0,10];	    %Variance 
    d3 = 600;                       %Length
    z3 = mvnrnd(m3,sigma3,d3);
    
elseif experiment == 2
    sc = 0.1;
    % Constraint 1
    m1 = sc*[-30;-15];	              %Mean
    sigma1 = sc^2*[5,10;10,30];	  %Variance
    d1 = 200;                         %Length
    z1 = mvnrnd(m1,sigma1,d1);


    % Constraint 2
    m2 = sc*[40;30];                  %Mean
    sigma2 = sc^2*[10,-10;-10,30];	  %Variance
    d2 = 250;                         %Length
    z2 = mvnrnd(m2,sigma2,d2);

    % Constraint 3
    m3 = sc*[-2;-20];	            %Mean
    sigma3 = sc^2*diag([3;10]);	    %Variance
    d3 = 300;                       %Length
    z3 = mvnrnd(m3,sigma3,d3);
end

%% 3) Setup feasibility constraints

% Physical limits of the joint
feasibility = {};
feasibility.q_upper_bound = 6;
feasibility.q_lower_bound = -6;
feasibility.qdot_upper_bound = 6;
feasibility.qdot_lower_bound = -6;
feasibility.margin = 0.1;



if plot_constraint
    sz=2;
    figure 
    scatter(z1(:,1),z1(:,2),'b')
    hold on
    scatter(z2(:,1),z2(:,2),'b')
    scatter(z3(:,1),z3(:,2),'b')
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_upper_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_lower_bound],'r','LineWidth',sz);
    plot([feasibility.q_lower_bound,feasibility.q_lower_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    plot([feasibility.q_upper_bound,feasibility.q_upper_bound],...
        [feasibility.qdot_lower_bound,feasibility.qdot_upper_bound],'r','LineWidth',sz);
    xlabel("$q$",'fontsize',16,'interpreter','latex')
    ylabel('$\dot{q}$','fontsize',16,'interpreter','latex')
    xlim([-7,7])
    ylim([-7,7])
end
 

% Use two sines as prior and ground truth of the torque   
RBD = @(A) 1.2*sin(sum(A,2)/50*pi);
y = @(A) 2.3*sin(sum(A,2)/50*pi);


%% 2) Model the constrained region with GMM and rotation order

% Group task regions into one dataset
X = [z1;z2;z3];

% Fit gmm with nb_gaussians components on the task regions
gm = fitgmdist(X,nb_gaussians);

% Determine rotation order of the regions
angle_from_center = atan2(gm.mu(:,2),gm.mu(:,1));
for i=1:nb_gaussians
    if angle_from_center(i) < 0
        angle_from_center(i) = angle_from_center(i) + 2*pi;
    end
end
[~,rotation_order_idx] = sort(angle_from_center,'descend');


%% 3) Define parameters and init Incremental GPR 

% Structure containing parameters of optimization
param = {};
params.I_clust = [d1;d2;d3];     % Importance of each cluset
params.I_var = 2;               % Importance of the variance
params.traj_iter = 2;           % Index of the trajectory
params.region_thres = 2.5;      % Nb of "sigma" that is considered to be in region
params.boundary_thres = 4;       % Nb of "sigma" to be outside a region but still close enough
params.robot_step = 0.1;        % Size of the step for computing the next point
params.convergence_dist = 0.1;  % Distance to be close enough to goal
params.delta_T = 0.01;          % update frequency of robot (min: 0.005)
params.alpha = 0.8;            % convergence rate for rho
params.beta = 0.5;              % Convergence rate for theta
params.sparseness = 10;         % Add point of trajectory all n iterations
params.P = 20;                  % Number of random points for select method number 2  
params.M = 3;                   % Number of step from random points for select method number 3&4
params.N = 20;                  % Number of random directions for select method 3

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;



%% 4) Initialization of the joint position and goals in each region

% Number of steps
steps = 50;


%qc_center = mean(gm.mu(:,1));
qc_center = 0;
feasibility.qc_center = qc_center;


%% 5) Main loop

for jj=1:2
    
    % Initialize GP
    myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

    % Define staring postion of the "robot"
    x_start = [4,0];

    % Initialize trajectory vector for plotting purpose
    trajectory = zeros(1,2);
    trajectory(1,:) = x_start;
    
    if jj==1
        % Initialize the goal of each region to be the center of the region
        X_next = gm.mu;     % (nb_gaussians x N)

        % First point
        x_current = x_start;

        % Compute limit cylce passing through each "next" point in region
        [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);

        % Compute first trajectory of the limit cycle
        if complete_traj == 1
            [points_to_add, x_current, trajectory, params] = complete_trajectory_angle_criterium(opt_rho, ...
                opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
        else
            [points_to_add, x_current, trajectory, params] = complete_trajectory_distance_criterium(opt_rho, ...
                opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
        end
    elseif jj==2
        % First point
        x_current = x_start;
        
        myGPR = myGPR.update(x_current, y(x_current), RBD(x_current));
        myGPR = myGPR.fit();
        
        % Select next point to go to
        [x_next, params] = select_point(gm, x_current, myGPR, feasibility, params);

        % Create limit cycle to go to the point
        [opt_rho, opt_qc] = limit_cycle(x_current, x_next, feasibility);

        % move along limit cycle until reaching destination
        [points_to_add, x_current, trajectory, params] = move_along_limit_cycle(opt_rho,...
                            opt_qc, x_current, x_next, gm, params, trajectory, false);
    end

    % Add point to model and compute updated GP incrementally
    for j=1:size(points_to_add,1)
        myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
    end
    myGPR = myGPR.fit();

    % Compute prediction error in task domain
    if do_prediction_accuracy
        prediction_error = zeros(steps,1);
        [ypred, ~] = myGPR.predict(X, RBD(X));
        prediction_error(1) = norm(ypred-y(X),2);
    end

    % Compute the overall variance evolution in the regions
    if do_variance_computation
        variance_region = zeros(steps,1);
        [~,yVar] = myGPR.predict(X,false);
        variance_region(1) = sum(abs(yVar));
    end



    %% 6) Loop over main that balances exploration and exploitation

    x_n_visualize = zeros(3*steps,2);

    % Train incrementally by balancing exploration and task constraints
    for i=1:steps
        
        if jj==1
            [X_next,params] = select_next_in_region2(gm, X_next, myGPR, feasibility, params);
            
            % Create limit cycles to go to the point
            [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility);

            % move along limit cycles until reaching destination (2pi rotation)
            if complete_traj == 1
                [points_to_add, x_current, trajectory, params] = complete_trajectory_angle_criterium(opt_rho, ...
                    opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
            else
               [points_to_add, x_current, trajectory, params] = complete_trajectory_distance_criterium(opt_rho, ...
                    opt_qc, x_current, X_next, gm, params, trajectory, rotation_order_idx);
            end
            
            
        elseif jj==2
            % Select next point to go to
            [x_next, params] = select_point(gm, x_current, myGPR, feasibility, params);

            % Create limit cycle to go to the point
            [opt_rho, opt_qc] = limit_cycle(x_current, x_next, feasibility);

            % move along limit cycle until reaching destination
            [points_to_add, x_current, trajectory, params] = move_along_limit_cycle(opt_rho,...
                                opt_qc, x_current, x_next, gm, params, trajectory, false);
        end
    



        % Increment importance of exploration
        params.I_var = 0.25+3*i/(4*steps);


        % Add point to model and compute updated GP incrementally
        for j=1:size(points_to_add,1)
            myGPR = myGPR.update(points_to_add(j,:), y(points_to_add(j,:)), RBD(points_to_add(j,:)));
        end
        myGPR = myGPR.fit();

        % Compute error in task domain
        if do_prediction_accuracy
            [ypred, ~] = myGPR.predict(X, RBD(X));
            prediction_error(i) = norm(ypred-y(X),2);
        end

        % Compute the overall variance evolution in the regions
        if do_variance_computation
            [~,yVar] = myGPR.predict(X, false);
            variance_region(i) = sum(abs(yVar));
        end


        % Display during computation
        if mod(i,1)==0
            disp("Method: " + string(jj) + "  Iteration: " + string(i) + "/" + string(steps));
        end
    end
    
    if jj == 1
        trajectory1 = trajectory;
        prediction_error1 = prediction_error;
        variance_region1 = variance_region;
        
    elseif jj == 2
        trajectory2 = trajectory;
        prediction_error2 = prediction_error;
        variance_region2 = variance_region;
    end
        
    
end






%% 7) Plot results

if do_prediction_accuracy
    if plot_error
        figure 
        plot(1:length(prediction_error2),prediction_error2,'b');
        hold on
        plot(1:length(prediction_error1),prediction_error1,'k');
        xlabel("Number of limit cycles",'fontsize',16,'interpreter','latex')
        ylabel("Sum of errors in Torque prediction $[Nm]$",'fontsize',16,'interpreter','latex')
        legend("Method 1","Method 2",'fontsize',12,'interpreter','latex')
    end
end



if do_variance_computation
    if plot_error
        figure 
        plot(1:length(variance_region2),variance_region2,'b');
        hold on
        plot(1:length(variance_region1),variance_region1,'k');
        plot(1:length(variance_region2),variance_region2,'b');
        xlabel("Number of limit cycles",'fontsize',16,'interpreter','latex')
        ylabel("Sum of prediction variance $[N^2m^2]$",'fontsize',16,'interpreter','latex')
        legend("Method 1","Method 2",'fontsize',12,'interpreter','latex')
    end
end