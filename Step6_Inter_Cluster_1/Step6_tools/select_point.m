function [x_next,params] = select_point(gm, x_current, GPR, feasibility, params)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION RETURNS THE NEXT DATAPOINT TO GO TO BY BALANCING
% EXPLORATION AND TASK CONSTRAINTS
%
% Input: - gm             : (object) GMM model fit on task constraints
%        - x_current      : (1xP) Last considered datapoint of dimension P
%        - GPR            : (object) Gaussian Process Regressor
%        - feasibility    : (struct) Feasibility constraints of robot
%        - params         : (struct) Parameters
%
%
% Ouput: - x_next         : (1xP) vector containing the next datapoint
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Function that computes the Mahalanobis distance
MahaDist = @(x,idx) sqrt(diag((x-gm.mu(idx,:))*(gm.Sigma(:,:,idx)\(x-gm.mu(idx,:))')));

% Compute weight based on distance and importance
dist = pdist2(gm.mu,x_current);
weights = 1./(1+dist).*params.I_clust/sum(params.I_clust);

% Select max weight and compute the step towards the center of the GM
[~, idx_gm] = max(weights);
diffX = gm.mu(idx_gm,:)-x_current;
deltaW = diffX/norm(diffX,2)*params.robot_step;

% Decrease importance of the chosen cluster
params.I_clust(idx_gm) = 0.95*params.I_clust(idx_gm);

% Select maximum variance direction
grad_var = GPR.gradient_var(x_current);
deltaVar = grad_var*params.robot_step;

% Compute probability associated to datapoint
M_distance = MahaDist(x_current,idx_gm);

if M_distance < params.region_thres
    % Case: In region --> Mainly exploration
    I_dist = 0;         % small I dist when in region
    deltaX = I_dist/(I_dist+params.I_var) * deltaW + params.I_var/(I_dist+params.I_var) * deltaVar;
    x_next = x_current + deltaX;  %Update datapoint
    
elseif M_distance < params.boundary_thres
    % Case: Going out of region --> give more weights to attractor
    I_dist = dist(idx_gm)/(1+dist(idx_gm));         % normalized between[0,1]
    deltaX = I_dist/(I_dist+params.I_var) * deltaW + params.I_var/(I_dist+params.I_var) * deltaVar;
    x_next = x_current + deltaX;  %Update datapoint
    
else
    % Case: Far from region --> Go to center of region!
    x_next = gm.mu(idx_gm,:);
    
end


% Ensure that x is feasible (reduce step if not)
t = 0.9;
while not(is_feasible_point(x_next,feasibility))
    deltaX = t*deltaX;
    x_next = x_current + deltaX;  
end

end