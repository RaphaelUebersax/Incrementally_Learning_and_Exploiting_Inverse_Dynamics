function [opt_rho, opt_qc] = limit_cycle(x_current, x_next, feasibility)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION RETURNS THE LIMIT CYCLE TO GO TO THE NEXT DATAPOINT WHILE
% ENSURING FEASIBILITY CONSTRAINTS.
%
% Input: - x_current      : (1xP) Last considered datapoint of dimension P
%        - x_next         : (1xP) Goal datapoint of dimension P
%        - feasibility    : (struct) Feasibility constraints of robot
%
%
% Ouput: - rho            : (double) Radius of limit cycle
%        - qc             : (double) Center of limit cycle 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% First compute unique limit cylce passing exactly through both points
% The if not feasible, solve optimization problem

% Compute mean of x_current and x_next and the normal to the line segment
mu = (x_current+x_next)./2;
normal = [-(x_next(2)-x_current(2)), (x_next(1)-x_current(1))];

% Intercept: mu(2)+t*normal(2) == 0
t = -mu(2)/normal(2);

% Compute correspondin rho and qc of the limit cycle
q_c = mu(1) + t*normal(1);
r = norm(x_current-[q_c,0],2);


% Check if optimal limit cycle is feasible
if is_feasible_limit_cycle(q_c, r, feasibility)
    opt_rho = r;
    opt_qc = q_c;
    
elseif is_feasible_arc(q_c,r,feasibility,x_current,x_next)
    opt_rho = r;
    opt_qc = q_c;
    
else

    % variable
    rho = sdpvar(1);
    qc = sdpvar(1);

    % Constraints
    constraints = [];
    constraints = [constraints, rho >= 0]; 
    constraints = [constraints, feasibility.q_upper_bound >= qc + rho];
    constraints = [constraints, feasibility.q_lower_bound <= qc - rho];
    constraints = [constraints, feasibility.qdot_upper_bound >= rho];
    constraints = [constraints, feasibility.qdot_lower_bound <= rho];
    constraints = [constraints, sum((x_next-[qc,0]).^2) >= rho^2];
    constraints = [constraints, sum((x_next-[qc,0]).^2) <= rho^2];

    %objective
    %objective = sum((x_current-[qc,0]).^2)-rho^2;  %X_current close to limit 
    objective = rho;

    % settings
    opt_settings = sdpsettings('solver','gurobi','verbose',0);

    % Diagnosis
    optimize(constraints, objective, opt_settings);

    % retrieve and display optimal solution values
    opt_rho = value(rho);
    opt_qc = value(qc);
end

end