
clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
rng('default');

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

% Define staring postion of the "robot"
x_start = [1,0.5];

% Use two sines as prior and ground truth of the torque   
RBD = @(A) 1.2*sin(sum(A,2)/50*pi);
y = @(A) 2.3*sin(sum(A,2)/50*pi);

% Iteration 1: First point
x_current = x_start;

x_train = x_start + randn(20,2);
for i=1:size(x_train,1)
    x_current = x_train(i,:);
    myGPR = myGPR.update(x_current, y(x_current), RBD(x_current));
    myGPR = myGPR.fit();
end



% Define variable to optimize for
z = optimvar('z',1,2);

% Define objective
objective = myGPR.variance(z);
prob = optimproblem('Objective',objective,'ObjectiveSense','max');
options = optimoptions(prob);
options.OptimalityTolerance = 1e-2;
options.MaxFunctionEvaluations = 500;

%Define constraints
constraint1 = -4 <= z(1); 
constraint2 = z(1)<= 4;
constraint3 = -2 <= z(2);
constraint4 = z(2) <= 2;

tic
constraint5 = z(1)-x_current(1) <= 0.1;
constraint6 = -0.1 <= z(1)-x_current(1);
constraint7 = z(2)-x_current(2) <= 0.1;
constraint8 = -0.1 <= z(2)-x_current(2);
constraint9 =  x_current(2)*(z(1)-x_current(1))>=0;
constraint10 =  x_current(1)*(z(2)-x_current(2))<=0;

prob.Constraints.LB_q = constraint1;
prob.Constraints.UB_q = constraint2;
prob.Constraints.LB_qdot = constraint3;
prob.Constraints.UB_qdot = constraint4;
prob.Constraints.UB_delta_q = constraint5;
prob.Constraints.LB_delta_q = constraint6;
prob.Constraints.UB_delta_qdot = constraint7;
prob.Constraints.LB_delta_qdot = constraint8;
prob.Constraints.feasibility_1 = constraint9;
prob.Constraints.feasibility_2 = constraint10;

z0.z = x_start;
toc
tic
[sol,fval,exitflag,output] = solve(prob,z0);
toc



                        




