
clear all;
close all;
clc;

addpath("../Tools");
addpath("../Regressors");
rng('default');

% Initialize GP
budget = 600;                  
Sigma_n = 0.1;
Sigma_rbf = 0.4;
Sigma_f = 1;
myGPR = CholBudgetGPRegressor(budget, Sigma_rbf, Sigma_n, Sigma_f);

% Define staring postion of the "robot"
x_start = [1,0.5];

% Use two sines as prior and ground truth of the torque   
RBD = @(A) 1.2*sin(sum(A,2)/50*pi);
y = @(A) 2.3*sin(sum(A,2)/50*pi);

% Iteration 1: First point
x_current = x_start;

x_train = x_start + randn(20,2);
for i=1:size(x_train,1)
    x_current = x_train(i,:);
    myGPR = myGPR.update(x_current, y(x_current), RBD(x_current));
    myGPR = myGPR.fit();
end

% variable
z = sdpvar(1,2);

%objective
objective = z(1)+z(2);

% constraints
constraints = [];
constraints = [constraints, -4 <= z(1)<= 4]; 
constraints = [constraints,-2 <= z(2) <= 2];
constraints = [constraints,-0.1 <= z(1)-x_start(1) <= 0.1];
constraints = [constraints,-0.1 <= z(2)-x_start(2) <= 0.1];
constraints = [constraints,x_start(2)*(z(1)-x_start(1))>=0];
constraints = [constraints,x_start(1)*(z(2)-x_start(2))<=0];

% settings
opt_settings = sdpsettings('solver','gurobi','verbose',0);

% Diagnosis
diagnosis = optimize(constraints, objective, opt_settings);

% retrieve and display optimal solution values
opt_z = value(z)

