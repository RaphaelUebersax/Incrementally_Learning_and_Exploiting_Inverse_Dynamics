function [opt_rho, opt_qc] = compute_limit_cycles(X_next, feasibility)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% THIS FUNCTION COMPUTES THE SOLUTION TO A OPTIMISATION PROBLEM WHICH
% DETERMINES THE LIMIT CYCLE REQUIRED TO BE ABLE TO MOVE THE ROBOT TO A
% DESIRED CONFIGURAITON WHILE ENSURING FEASIBILITY CONSTRAINTS.
%
% NOTE: REQUIRES GUROBI TO BE INSTALLED!!!
%
% Input: - X_next         : (nb_gaussians x P) Goal datapoint of dimension P
%        - feasibility    : (struct) Feasibility constraints of robot
%
%
% Ouput: - rho            : (nb_gaussians x 1) Radius of limit cycle
%        - qc             : (nb_gaussians x P) Center of limit cycle 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% initialize dimensions of output vector
nb_gaussians = size(X_next,1);
opt_rho = zeros(nb_gaussians,1);
opt_qc = zeros(nb_gaussians,1);

% Loop over each optimization problem to solve
for i=1:nb_gaussians
    
    % variable
    rho = sdpvar(1);
    qc = sdpvar(1);

    % Constraints
    constraints = [];
    constraints = [constraints, rho >= 0]; 
    constraints = [constraints, feasibility.q_upper_bound >= qc + rho];
    constraints = [constraints, feasibility.q_lower_bound <= qc - rho];
    constraints = [constraints, feasibility.qdot_upper_bound >= rho];
    constraints = [constraints, feasibility.qdot_lower_bound <= rho];
    constraints = [constraints, sum((X_next(i,:)-[qc,0]).^2) >= rho^2];
    constraints = [constraints, sum((X_next(i,:)-[qc,0]).^2) <= rho^2];

    %objective 
    objective = abs(qc-feasibility.qc_center);%+ abs(feasibility.e1(i,:)*(X_next(i,:)-[qc,0])');

    % settings
    opt_settings = sdpsettings('solver','gurobi','verbose',0);

    % Solve the optimization problem
    diagnosis = optimize(constraints, objective, opt_settings);
    % retrieve optimal solution values
    opt_rho(i) = value(rho);
    opt_qc(i) = value(qc);

end